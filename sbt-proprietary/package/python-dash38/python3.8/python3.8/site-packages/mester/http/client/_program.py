"""Program HTTP interface."""
import json
import logging
from contextlib import AsyncExitStack

import aiohttp
from async_timeout import timeout
from geist.basic import keys_to_snake_case
from geist.http.client import Session

_LOGGER = logging.getLogger(__name__)


class Program:
	"""Client interface for program."""

	def __init__(self, session):
		"""Construct client that connects with the given session."""
		self._session = session
		self._name = None

	async def start(self, name):
		"""Start the program with the given name."""
		try:
			url = f'{self._session.url}/tasks/program'
			async with self._session.put(url, data=name.encode()):
				pass
		except aiohttp.ClientConnectionError as error:
			raise aiohttp.ClientConnectionError(f'Program error: Unable to communicate.')
		except aiohttp.ClientError as error:
			raise aiohttp.ClientError(f'Program error: {error}')

	async def stop(self):
		"""Stop the current program."""
		# Some programs take a long time to stop. E.g., the measure
		# programs wants to empty the system first. Therefore, we
		# increase the total timeout to 2 minutes (the geist default
		# is 10 seconds and the aiohttp default is 5 minutes).
		stop_timeout = aiohttp.ClientTimeout(total=120)
		try:
			url = f'{self._session.url}/tasks/program'
			async with self._session.delete(url, timeout=stop_timeout):
				pass
		except aiohttp.ClientResponseError as error:
			# Ignore 'not found' errors (which implies that the program is already stopped).
			if 404 == error.status:
				return
			raise
		except aiohttp.ClientConnectionError as error:
			raise aiohttp.ClientConnectionError(f'Program error: Unable to communicate.')
		except aiohttp.ClientError as error:
			raise aiohttp.ClientError(f'Program error: {error}')

	async def status(self, *, suppress_errors=False):
		"""Return async generator with regular status reports."""
		url = f'{self._session.url}/tasks/program'
		options = {
			'timeout': 3,
			'receive_timeout': 3,
		}
		# Use a local session to avoid blocking other queries in the session.
		# It's a bug in the aiohttp client. See the comment in
		# `baxter.http.client.Measurement._query_report` for details.
		local_session = Session(
			self._session._hostname,
			self._session._port,
			raise_for_status=self._session._raise_for_status
		)
		try:
			async with AsyncExitStack() as stack:
				await stack.enter_async_context(local_session)
				connection = local_session.ws_connect(url, **options)
				# The timeouts given in `options` do not apply to the
				# initial connection itself. Therefore, we use a custom
				# timeout here.
				async with timeout(3):
					ws = await stack.enter_async_context(connection)
				async for msg in ws:
					data = json.loads(msg.data)
					# Raise on error
					error = data.get('error')
					if error is not None:
						# Suppress if specified
						if suppress_errors:
							continue
						raise aiohttp.ClientError(f'Program error: {error}')
					# No error, so value must be present
					value = data['value']
					yield value
		except aiohttp.ClientConnectionError as exc:
			raise aiohttp.ClientConnectionError(f'Program error: Unable to communicate.') from exc

	async def get_measurement(self, index=0):
		"""Return the measurement with the given index."""
		async with self._session.get(f'{self._session.url}/tasks/program/measurements') as resp:
			measurements = await resp.json()
			try:
				measurement = measurements[index]
			except IndexError:
				n = len(measurements)
				raise aiohttp.ClientError(
					f'Program error: Given measurement index ({index}) is invalid. '
					f'There are {n} measurement(s) associated with this program.'
				)
			name = measurement['name']
		url = f'{self._session.url}/tasks/program/measurements/{name}.json'
		async with self._session.get(url) as resp:
			measurement = await resp.json()
			if measurement is None:
				return None
			# Save 'messages' since we do not want the keys to be converted.
			# I.e., keys like 'E801' should not be converted to 'e801'.
			messages = measurement.pop('messages', {})
			measurement = keys_to_snake_case(measurement)
			measurement['messages'] = messages
			return measurement

	async def flow(self):
		"""Return async generator with latest flow reports."""
		# Use a local session to avoid blocking other queries in the session.
		# It's a bug in the aiohttp client. See the comment in
		# `baxter.http.client.Measurement._query_report` for details.
		local_session = Session(
			self._session._hostname,
			self._session._port,
			raise_for_status=self._session._raise_for_status
		)
		try:
			async with AsyncExitStack() as stack:
				await stack.enter_async_context(local_session)
				connection = local_session.ws_connect(f'{local_session.url}/tasks/program/flow/sinks/json')
				# Other timeouts do not apply. Use a custom timeout to avoid stalls.
				# Must be a bug in aiohttp.
				async with timeout(3):
					ws = await stack.enter_async_context(connection)
				async for msg in ws:
					yield json.loads(msg.data)
		except aiohttp.ClientConnectionError:
			raise aiohttp.ClientConnectionError(f'Program error: Unable to communicate.')
