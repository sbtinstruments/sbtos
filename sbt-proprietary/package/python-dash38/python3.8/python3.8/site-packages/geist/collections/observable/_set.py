import logging
from typing import Iterator, Optional, TypeVar

from . import diffs, abc

_LOGGER = logging.getLogger(__name__)

AT = TypeVar("AT")
VT = TypeVar("VT")


class Set(abc.Set[AT, VT]):
	"""Observable set."""

	def __init__(self, *, author: Optional[AT] = None) -> None:
		super().__init__(author=author)
		self._data = set()

	def apply(self, *differences: diffs.SetDiffs) -> None:
		"""Apply the given diffs to this collection."""
		for diff in differences:
			# Ignore diffs that we have already applied (put our stamp on)
			if self._author in diff.stamps:
				continue
			if isinstance(diff, diffs.RemoveValue):
				self.discard(diff.value, diff=diff)
			elif isinstance(diff, diffs.AddValue):
				self.add(diff.value, diff=diff)
			else:
				raise ValueError(f"Unknown diff: {diff}")

	def __len__(self) -> int:
		return len(self._data)

	def __iter__(self) -> Iterator[VT]:
		return iter(self._data)

	def __contains__(self, value: VT) -> bool:
		return value in self._data

	def add(self, value: VT, *, diff: Optional[diffs.AddValue] = None) -> None:
		# Change detection
		changed = value not in self
		# Early out
		if not changed:
			return
		# Mutation
		self._data.add(value)
		# Change notification
		if changed:
			if diff is None:
				diff = diffs.AddValue(self._author, value)
			else:
				# Add our stamp to the diff so that we won't apply it twice
				diff = diff.add_stamp(self._author)
			self._changes.on_next(diff)

	def discard(self, value: VT, *, diff: Optional[diffs.RemoveValue] = None) -> None:
		# Change detection
		changed = value in self
		if not changed:
			return
		# Mutation
		self._data.discard(value)
		# Change notification
		if changed:
			if diff is None:
				diff = diffs.RemoveValue(self._author, value)
			else:
				# Add our stamp to the diff so that we won't apply it twice
				diff = diff.add_stamp(self._author)
			self._changes.on_next(diff)

	def __repr__(self) -> str:
		return repr(self._data)
