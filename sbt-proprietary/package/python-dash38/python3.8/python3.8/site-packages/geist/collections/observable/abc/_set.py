import typing
from abc import abstractmethod
from typing import Iterable, Optional, Callable

import rx
from rx import Observable
from rx import operators as ops
from rx.subject import Subject

from .. import diffs
from ._collection import Collection

AT = typing.TypeVar("AT")
VT = typing.TypeVar("VT")


class Set(Collection[AT], typing.Set[VT]):
	"""Set with built-in change detection."""

	def __init__(self, *, author: Optional[AT] = None) -> None:
		super().__init__(author=author)
		self._changes = Subject()

	def changes(self, start_with_copy: bool = False) -> Observable:
		obs = self._changes
		if start_with_copy:
			# Call `copy_as_diffs` inside the `flat_map` operator to ensure
			# that the call will be made at the time of the subscription
			# and *not* at the time of this call to `changes`.
			copy = rx.just(None).pipe(
				ops.flat_map(lambda _: rx.from_iterable(self.copy_as_diffs()))
			)
			obs = rx.concat(copy, obs)
		return obs

	def copy_as_diffs(self) -> Iterable[diffs.AddValue]:
		"""Return the a copy of this as an iterable of diffs.

		The returned diffs (applied in sequence on an empty mapping) will
		constitute a copy of this instance.
		"""
		return (
			diffs.AddValue(self._author, value)
			for value in self
		)

class MutableSet(Set[AT, VT], typing.MutableSet[VT]):
	"""Mutable set with built-in change detection."""

	@abstractmethod
	def apply(self, *differences: diffs.SetDiffs) -> None:
		"""Apply the given diffs to this collection."""
