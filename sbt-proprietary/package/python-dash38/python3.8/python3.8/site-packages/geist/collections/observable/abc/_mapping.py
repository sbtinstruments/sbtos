import typing
from abc import abstractmethod
from typing import Iterable, Optional, Callable

import rx
from rx import Observable
from rx import operators as ops
from rx.subject import Subject

from .. import diffs
from ._collection import Collection

AT = typing.TypeVar("AT")
KT = typing.TypeVar("KT")
VT = typing.TypeVar("VT")


class Mapping(Collection[AT], typing.Mapping[KT, VT]):
	"""Mapping with built-in change detection."""

	def __init__(self, *, author: Optional[AT] = None) -> None:
		super().__init__(author=author)
		self._changes = Subject()

	def changes(self, start_with_copy: bool = False) -> Observable:
		"""Return observable of changes (diffs) made to this mapping.

		Use `start_with_copy` to initialize the observable with
		`diffs.SetItem` instances for each item in this mapping.

		Note that that the "copy" is made at the time of the subscription.
		This way, an observable created up front will still include
		items added subsequently. E.g.:

		  # Create the observable up front
		  obs = map.changes(start_with_copy=True)
		  # Modify the map
		  map["a"] = 32
		  map["b"] = -7
		  obs.subscribe(print)  # Will also print for "a" and "b"
		"""
		obs = self._changes
		if start_with_copy:
			# Call `copy_as_diffs` inside the `flat_map` operator to ensure
			# that the call will be made at the time of the subscription
			# and *not* at the time of this call to `changes`.
			copy = rx.just(None).pipe(
				ops.flat_map(lambda _: rx.from_iterable(self.copy_as_diffs()))
			)
			obs = rx.concat(copy, obs)
		return obs

	def copy_as_diffs(self) -> Iterable[diffs.SetItem]:
		"""Return the a copy of this as an iterable of diffs.

		The returned diffs (applied in sequence on an empty mapping) will
		constitute a copy of this instance.
		"""
		return (
			diffs.SetItem(self._author, key, value)
			for key, value in self.items()
		)

class MutableMapping(Mapping[AT, KT, VT], typing.MutableMapping[KT, VT]):
	"""Mutable mapping with built-in change detection."""

	@abstractmethod
	def apply(self, *differences: diffs.MapDiffs) -> None:
		"""Apply the given diffs to this collection.

		If the `apply` call triggers a state change, the original author (from
		this call to `apply`) will also be the author of the emitted diff.

		  data = observable.Dict(author="frederik")
		  data.changes().subscribe(print)  # <-- will show "timon"
		  data["a"] = 2
		  data.apply(diffs.DelItem("timon", "a"))  # Timon's diff

		Anonymous diffs (when `author` is `None`) are treated specially.
		If the `apply` call triggers a state change, this map will take
		authorship of any anonymous diffs.

		  data = observable.Dict(author="frederik")
		  data.changes().subscribe(print)  # <-- will show "frederik"
		  data["a"] = 2
		  data.apply(diffs.DelItem(None, "a"))  # Anonymous diff

		"""
		...
