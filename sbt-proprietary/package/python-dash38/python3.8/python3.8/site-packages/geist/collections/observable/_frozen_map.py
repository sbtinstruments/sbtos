from __future__ import annotations

from typing import Iterator, Optional, TypeVar

import immutables

from . import diffs, abc

AT = TypeVar("AT")
KT = TypeVar("KT")
VT = TypeVar("VT")


class FrozenMap(abc.Mapping[AT, KT, VT]):
	"""Observable frozen map."""

	def __init__(
		self,
		*,
		author: Optional[AT] = None,
		data: Optional[immutables.Map] = None,
	) -> None:
		super().__init__(author=author)
		if data is None:
			data = immutables.Map()
		self._data = data

	def apply(self, *differences: diffs.MapDiffs) -> FrozenMap:
		"""Apply the given diffs to this collection."""
		result = self
		for diff in differences:
			# Ignore diffs that we have already applied (put our stamp on)
			if self._author in diff.stamps:
				continue
			if isinstance(diff, diffs.DelItem):
				try:
					result = self.delete(diff.key, diff=diff)
				except KeyError:
					# If the item is already deleted, the diff is already
					# applied. I.e., there is no reason to raise an error.
					continue
			elif isinstance(diff, diffs.SetItem):
				result = self.set(diff.key, diff.value, diff=diff)
			else:
				raise ValueError(f"Unknown diff: {diff}")
		return result

	def __len__(self) -> int:
		return len(self._data)

	def __iter__(self) -> Iterator[KT]:
		return iter(self._data)

	def __getitem__(self, key: KT) -> VT:
		return self._data[key]

	def __repr__(self) -> str:
		return repr(self._data)

	def set(self, key: KT, value: VT, *, diff: Optional[diffs.SetItem] = None) -> FrozenMap:
		# Change detection
		try:
			changed = self[key] != value
		except KeyError:
			changed = True
		# Early out
		if not changed:
			return self
		# Mutation
		result = self._wrap(self._data.set(key, value))
		# Change notification
		if changed:
			if diff is None:
				diff = diffs.SetItem(self._author, key, value)
			else:
				# Add our stamp to the diff so that we won't apply it twice
				diff = diff.add_stamp(self._author)
			self._changes.on_next(diff)
		return result

	def delete(self, key: KT, *, diff: Optional[diffs.DelItem] = None) -> None:
		# Change detection
		changed = key in self
		# Early out
		if not changed:
			return self
		# Mutation
		result = self._wrap(self._data.delete(key))
		# Change notification
		if changed:
			if diff is None:
				diff = diffs.DelItem(self._author, key)
			else:
				# Add our stamp to the diff so that we won't apply it twice
				diff = diff.add_stamp(self._author)
			self._changes.on_next(diff)
		return result

	def _wrap(self, data: immutables.Map) -> FrozenMap:
		return FrozenMap(author=self._author, data=data)
