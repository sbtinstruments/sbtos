from __future__ import annotations

import logging
from typing import Generic, Optional, TypeVar

from ._task_barrier import task_barrier
from ...asyncio import Rift
from .. import Client
from ._input import Input
from ._output import Output
from .collections import Mapping as DepoMapping

_LOGGER = logging.getLogger(__name__)

VT = TypeVar("VT")


class Bind(Generic[VT]):

	def __init__(
		self,
		client: Client,
		name: str,
		*,
		retain_debounce: Optional[float] = None
	) -> None:
		self._client = client
		self._name = name
		if retain_debounce is None:
			retain_debounce = 0.5  # [seconds]
		self._retain_debounce = retain_debounce
		self._rift = Rift(name="bind")

	async def sync_map(self, map_: DepoMapping[VT]) -> None:
		"""Synchronize this depo with the given map (both directions).

		The synchronization will continue in the background for the
		duration of the returned context manager.
		"""
		# Note that it is important that the two context managers,
		# `Input` and `Output`, are split into separate tasks. Otherwise,
		# an exception from the "outer" context manager will hide an
		# exception from the "inner" context manager.
		#
		# E.g.: Don't do it like this:
		#
		#   async with Input(...) as inp, Output(...) as out:
		#       ...
		#
		# If `Output.__aexit__` raises `RuntimeError` and `Input.__aexit__`
		# raises `CancelledError`, only the `CancelledError` is propagated
		# *even if `Output.__aexit__` raises first*.
		async def _sync_map_to_depo(ready):
			"""Synchronize from the map to this depo."""
			inp = Input(self._client, self._name, map_.apply)
			async with inp:
				await inp.wait_for_retained()
				ready()

		async def _sync_depo_to_map(ready):
			"""Synchronize from the map to this depo."""
			map_changes = map_.changes(start_with_copy=True)
			out = Output(self._client, self._name, map_changes)
			async with out:
				ready()

		await task_barrier(self._rift, _sync_map_to_depo, _sync_depo_to_map)

	def cancel(self) -> None:
		self._rift.cancel()

	async def __aenter__(self) -> Bind:
		await self._rift.__aenter__()
		return self

	async def __aexit__(self, exc_type, exc_value, traceback) -> None:
		await self._rift.__aexit__(exc_type, exc_value, traceback)
