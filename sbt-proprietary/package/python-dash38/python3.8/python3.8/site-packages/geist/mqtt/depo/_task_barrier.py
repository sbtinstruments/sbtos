import asyncio
from functools import wraps
from typing import Awaitable, Callable

from ...asyncio import Rift


ReadyFunc = Callable[[], None]
Coro = Callable[[ReadyFunc], Awaitable[None]]

async def task_barrier(rift: Rift, *coros: Coro) -> None:
	"""Create a task for each given coro and wait for them all.

	Returns when either:
	  1. All coros have completed or called the `ready` function
	  2. A coro raises an exception

	In the case of (2), said exception is propagated to the caller. The
	other tasks are not cancelled and will continue to run. When the
	rift exits, the other tasks will be cancelled as usual.
	"""
	result = asyncio.Future()
	pending = set(coros)

	def _create_ready_func(coro):
		def _ready():
			"""Call when the task is ready.

			This function is idempotent. I.e., multiple calls will
			have no effect.
			"""
			pending.discard(coro)
			if not pending:
				result.set_result(None)
		return _ready

	def _create_coro_wrapper(coro):
		@wraps(coro)
		async def _wrapper():
			ready = _create_ready_func(coro)
			try:
				await coro(ready)
			except BaseException as exc:
				if not result.done():
					result.set_exception(exc)
				raise
			else:
				ready()
		return _wrapper

	for coro in coros:
		rift.create_task(_create_coro_wrapper(coro)())
	await result
