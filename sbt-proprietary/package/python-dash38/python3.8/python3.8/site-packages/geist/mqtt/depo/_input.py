from __future__ import annotations

import asyncio
import json
import logging
import sys
from typing import Awaitable, Callable

from rx import operators as ops
from rx.scheduler.eventloop import AsyncIOScheduler
from rx.subject import Subject

from ...asyncio import Rift
from ...collections.observable import diffs
from .. import Client, SubscribeOptions
from ._task_barrier import task_barrier
from ._val import Val

Callback = Callable[[diffs.MapDiffs], None]

_LOGGER = logging.getLogger(__name__)


class Input:
	"""Input from a MQTT collection topic to a callback."""

	def __init__(
		self,
		client: Client,
		depo_name: str,
		callback: Callback,
	) -> None:
		self._client = client
		self._depo_name = depo_name
		self._callback = callback
		self._rift = Rift()
		self._scheduler = AsyncIOScheduler(asyncio.get_event_loop())
		self._messages = Subject()

	async def wait_for_retained(self, debounce: float = 0.5) -> Awaitable[None]:
		"""Wait until we have received all retained messages."""
		# Early out if we don't want to wait for retained messages (if any)
		if debounce <= 0:
			return
		# The broker will send us all retained messages shortly after
		# the subscription goes through. There is no telling when we
		# are done receiving retained messages. Instead, we simply
		# wait until we haven't received another message for
		# `retain_debounce` seconds.
		await self._messages.pipe(
			ops.filter(lambda m: m.retain),
			# Ensure progress even if there are no retained messages
			ops.start_with(None),
			ops.debounce(debounce, scheduler=self._scheduler),
			ops.first(),
		)

	async def _track_changes(self, ready) -> None:
		topic = self._topic()
		async with self._client.filtered_messages(topic) as messages:
			# "noLocal" to avoid needlessly sending the changes
			# that we just made to ourselves.
			options = SubscribeOptions(qos=2, noLocal=True)
			await self._client.subscribe(topic, options=options)
			ready()
			async for message in messages:
				diff = self._to_diff(message)
				self._callback(diff)
				self._messages.on_next(message)

	def _to_diff(self, message) -> diffs.MapDiffs:
		topic = message.topic
		# E.g.: "depo1/recipes/lasagne" -> "lasagne"
		key = topic[topic.rfind("/") + 1:]
		user_props = dict(message.properties.UserProperty)
		last_modified_by = user_props["last_modified_by"]
		# The author of the diffs will be the client ID that last modified
		# the depo item.
		author = last_modified_by
		# _LOGGER.debug(f"subscribe MSG: last_modified_by={last_modified_by} topic={topic}")
		if message.payload:
			# If there is a payload, it is a "set" operation
			value = json.loads(message.payload.decode())
			return diffs.SetItem(author, key, Val.simple(value, last_modified_by=last_modified_by))
		# If the payload is empty, it is a "delete" operation
		return diffs.DelItem(author, key)

	def _topic(self) -> str:
		return f"depo1/{self._depo_name}/+"

	async def __aenter__(self) -> Input:
		await self._rift.__aenter__()
		try:
			await task_barrier(self._rift, self._track_changes)
		except:
			# When an exception is raised in `__aenter__` then `__aexit__`
			# won't be called. Therefore, we do the cleanup here.
			if not await self._rift.__aexit__(*sys.exc_info()):
				raise
		return self

	async def __aexit__(self, exc_type, exc_value, traceback) -> None:
		await self._rift.__aexit__(exc_type, exc_value, traceback)
