from __future__ import annotations

import sys
import asyncio
import logging
from typing import Callable, Iterable, Optional, TypeVar, Union
from functools import partial

from rx import Observable
from rx import operators as ops

from ._task_barrier import task_barrier
from ...asyncio import Rift
from ...collections.observable import diffs
from ...rx.asyncio import to_agen
from .. import Client
from ._output import apply_changes
from ._bind import Bind
from ._val import Val
from .collections import Dict as DepoDict
from .collections import Mapping as DepoMapping
from .collections import OwnMapping as DepoOwnMapping

_LOGGER = logging.getLogger(__name__)

VT = TypeVar("VT")

SyncOp = Callable[[Observable], Observable]
SyncOps = Iterable[SyncOp]
SyncOpsArg = Optional[Union[SyncOp, SyncOps]]


class Depo(DepoDict):

	def __init__(
		self,
		client: Client,
		name: str,
		*,
		retain_debounce: Optional[float] = None,
		author = None,
		clear_own_on_enter: bool = True,
		clear_own_on_exit: bool = True,
	) -> None:
		super().__init__(author=author)
		self._client = client
		self._name = name
		self._retain_debounce = retain_debounce
		self._rift = Rift(name=f"depo1/{name}")
		self._clear_own_on_enter = clear_own_on_enter
		self._clear_own_on_exit = clear_own_on_exit

	async def sync_exclusive_map(self, map_: DepoOwnMapping[VT]) -> None:
		"""Synchronize between this depo and the map (both directions).

		The synchronization lasts until this depo's context is exitted.

		This depo can contain data from multiple clients. The map, however,
		must only contain data from a single client: Us. Only our own changes
		will be reflected in the map.

		This way, the map is special because it only contains data that is
		modified by us. E.g., `last_modified_by` will always be our client
		ID. In turn, this is why the data is stored "raw" in the map and
		not as a `depo.Val` instance.
		"""
		# Synchronize: From map to depo
		#
		# We add metadata (e.g., `last_modified_by`) to the diff:
		#   * "set" operations (additions and updates) will be marked as
		#     modified by this client.
		#   * Deletions go through unchanged, since they don't carry
		#     metadata.
		def _to_val(diff: diffs.MapDiffs) -> diffs.MapDiffs:
			if isinstance(diff, diffs.SetItem):
				return diff.replace_value(Val.simple(diff.value, last_modified_by=self._client.id))
			return diff
		map_to_depo = ops.map(_to_val)
		# Synchronize: From depo to map
		#
		# We remove metadata (e.g., `last_modified_by`) from the diff:
		#   * "set" operations (additions and updates) are treated specially
		#     (see below).
		#   * Deletions go through unchanged, since they don't carry
		#     metadata.
		def _to_data(diff: diffs.MapDiffs) -> diffs.MapDiffs:
			if isinstance(diff, diffs.SetItem):
				val = diff.value
				assert isinstance(val, Val), "Depo value type must be depo.Val"
				if val.metadata.last_modified_by != self._client.id:
					# The change did not come from us. Two possibilities:
					#   1. The item exists in the map
					#   2. The item does not exist on the map
					# In case of (1), another client has changed the item so
					# we need to remove the item from the map (since the map
					# should only contain entries modified by us).
					# In case of (2), we don't do anything.
					#
					# We convert the `SetItem` into a `DelItem`. When applied
					# to the map, the `DelItem` will either remove the item
					# from the map (1) or simply not do anything (2). Exactly
					# what we want.
					new_diff = diffs.DelItem(diff.author, diff.key)
					# Add the stamps of the original diff so that the `DelItem`
					# won't be erroneously applied to the source of the diff
					# when the changes propagate through the synchronization
					# network.
					new_diff = new_diff.add_stamps(diff.stamps)
					return new_diff
				# If we reach this point, the addition/update did come from
				# us. Recall that the map only consist of data modified by
				# us, so we don't have to store metadata (e.g.,
				# `last_modified_by`). Therefore, we discard the metadata
				# from the diff and only forward the "raw" data.
				return diff.replace_value(val.data)  # No `val.metadata`
			return diff
		depo_to_map = ops.map(_to_data)
		# Start synchronization
		await self.sync_map(
			map_,
			map_to_depo=map_to_depo,
			depo_to_map=depo_to_map,
		)

	async def sync_map(
		self,
		map_: DepoMapping[VT],
		*,
		map_to_depo: SyncOpsArg = None,
		depo_to_map: SyncOpsArg = None,
	) -> None:
		"""Synchronize between this depo and the map (both directions).

		The synchronization lasts until this depo's context is exitted.

		This depo can contain data from multiple clients. Said data also
		carries metadata that must be stored on the given map. This is
		why we expect the given map to use `depo.Val` as the value type.

		Use the `map_to_depo` and `depo_to_map` arguments to transform the data
		before it sent to the depo and sent to the map, respectively.
		"""
		# Normalize arguments.
		#
		# We accept both:
		#  * No operations at all
		#  * A single operation
		#  * A Tuple of operations
		#
		# We normalize all of the above to a tuple of operations.
		map_to_depo = _normalize_sync_ops(map_to_depo)
		depo_to_map = _normalize_sync_ops(depo_to_map)
		# Start synchronization
		await self._sync_map(
			map_,
			map_to_depo=map_to_depo,
			depo_to_map=depo_to_map,
		)

	async def _sync_map(
		self,
		map_: Union[DepoMapping[VT], DepoOwnMapping[VT]],
		*,
		map_to_depo: SyncOps,
		depo_to_map: SyncOps,
	) -> None:
		"""Synchronize this depo with the given map (both directions).

		The synchronization will continue in the background for the
		duration of the returned context manager.
		"""
		async def _apply_changes(changes: Observable, dest, ready) -> None:
			with to_agen(changes, name="depo._sync_map") as gen:
				ready()
				# Apply each incoming diff.
				async for diff in gen:
					dest.apply(diff)

		# Synchronize: From map to depo
		map_diffs = map_.changes(start_with_copy=True).pipe(*map_to_depo)
		sync_map_to_depo = partial(_apply_changes, map_diffs, self)
		# Synchronize: From depo to map
		self_diffs = self.changes(start_with_copy=True).pipe(*depo_to_map)
		sync_depo_to_map = partial(_apply_changes, self_diffs, map_)
		# Wait until both synchronization contexts are active
		await task_barrier(self._rift, sync_map_to_depo, sync_depo_to_map)

	def clear_own(self) -> None:
		"""Clear all entries that was last modified by this client."""
		self.apply(*self._delete_own_as_diffs())

	async def _clear_own_remote(self) -> None:
		"""Clear all entries that was last modified by this client.

		Applies the deletions directly to the remote depo. This is in
		contrast to `clear_own` that applies the changes to the local
		`observable.Dict`, which in turn applies the changes to the
		remote depo.
		"""
		await apply_changes(self._client, self._name, self._delete_own_as_diffs())

	def _delete_own_as_diffs(self) -> Iterable[diffs.DelItem]:
		our_changes = (
			d
			for d in self.copy_as_diffs()
			if d.value.metadata.last_modified_by == self._client.id
		)
		return (diffs.DelItem(d.author, d.key) for d in our_changes)

	def cancel(self) -> None:
		"""Stop all synchronization (if any is active)."""
		self._rift.cancel()

	async def _bind_self(self) -> None:
		"""Synchronize this `observable.Dict` with the remote depo.

		Note that we prefer to create a task in the rift to hold the
		`Bind` context manager. This is done so that the rift can
		prioritize any exceptions.
		It's analogous to how we use `_apply_changes` in `_sync_map`.
		"""
		async def _cm_task(ready):
			bind = Bind(
				self._client,
				self._name,
				retain_debounce=self._retain_debounce
			)
			async with bind:
				await bind.sync_map(self)
				ready()
		await task_barrier(self._rift, _cm_task)

	async def __aenter__(self) -> Depo:
		await self._rift.__aenter__()
		try:
			await self._bind_self()
		except:
			# When an exception is raised in `__aenter__` then `__aexit__`
			# won't be called. Therefore, we do the cleanup here.
			if not await self._rift.__aexit__(*sys.exc_info()):
				raise
		if self._clear_own_on_enter:
			# If a process crashed, there may still be entries in the
			# depo from the crashed session. It's common to delete
			# said entries so that the depo can be reconstructed
			# from scratch.
			self.clear_own()  # [1]
		return self

	async def __aexit__(self, exc_type, exc_value, traceback) -> None:
		try:
			await self._rift.__aexit__(exc_type, exc_value, traceback)
		finally:
			if self._clear_own_on_exit:
				# While there is nothing wrong with leaving our entries
				# in the depo on exit, it is common to remove them
				# before we exit. This way, the depo only has entries
				# from active sessions.
				# Of course, it can't be guaranteed that we exit cleanly
				# (e.g., the process could crash) so that is why it is
				# also common to remove our entries on enter (see [1]).
				#
				# Note that we use `_clear_own_remote` and not simply
				# `clear_own` since the latter only works while we
				# are bound to the remote depo.
				await self._clear_own_remote()


def _normalize_sync_ops(sync_ops: SyncOpsArg) -> SyncOps:
	if sync_ops is None:
		return tuple()
	if callable(sync_ops):
		return (sync_ops,)
	return sync_ops
