from __future__ import annotations

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import Awaitable, Callable, Optional
from uuid import uuid4

from ..app import app_name
from ..asyncio import Rift, retry, retry_context
from ..collections import observable
from ..collections.observable import diffs
from ..rx.asyncio import to_agen
from . import Client, MqttError

_LOGGER = logging.getLogger(__name__)


class TaskGroup:
	"""Automatically run coro tasks whenever the MQTT connection is established."""

	def __init__(
		self,
		host: str,
		*args,
		client_id: Optional[str] = None,
		**kwargs
	) -> None:
		# Arguments for the MQTT client
		self._host = host
		self._args = args
		if client_id is None:
			client_id = f"{app_name()}-{uuid4()}"
		self._client_id = client_id
		self._kwargs = kwargs
		# Persistent tasks
		self._coros = observable.Set()
		self._rift = Rift()

	@property
	def client_id(self) -> str:
		"""Return the MQTT client ID."""
		return self._client_id

	def on_connect(self, coro: Callable[[Client], Awaitable[None]]) -> None:
		"""Run the given coro whenever this client establishes a connection.

		In other words:

		  * When the client is connected, a new coro task is scheduled.
		  * When the client is disconnected, the coro task is cancelled.

		Use `on_connect` to, e.g., subscribe to topics. This way, the
		subscriptions are established again even if the client
		experiences some network issues.
		"""
		self._coros.add(coro)

	async def _main(self) -> None:
		"""Ensure that the coros are run whenever this client is connected.

		(Re)connect to the database whenever the connection is lost.
		When successful, run the coros.
		"""
		# If a task fails due to an MQTT-related issue, we
		# retry the connection.
		options = {
			"delay_func": lambda i: 1,  # Always wait 1 second
			"logger": _LOGGER,
			"expected_exceptions": (MqttError,),
			"log_error_msg": "MQTT error: {error}",
			"log_error_exc_info": False,
		}
		await retry(self._connect_and_run, **options)

	async def _connect_and_run(self):
		"""Connect to the MQTT broker and start the coro tasks."""
		# Create a new MQTT client. This will automatically retry the
		# connection until it succeeds.
		async with self._connected_client() as client:
			# Now that we got a connected client, we start the coro
			# tasks.
			await self._run_coros(client)

	async def _run_coros(self, client) -> None:
		"""Run the "on_connect" coroutines.

		If an error occurs, all coro tasks are cancelled. Said error is
		then propagated to the caller.

		If there are no coros to run,
		"""
		# Create a rift that automatically creates new tasks for each
		# coro added via `Client.on_connect`.
		async with self._task_rift(client) as rift:
			try:
				# Wait until a task fails
				await rift.wait(return_when=asyncio.FIRST_EXCEPTION)
			finally:
				# When a rift exits, it will wait for all its tasks to complete.
				# We don't want that. Therefore, we cancel the rift before
				# it exits.
				rift.cancel()

	@asynccontextmanager
	async def _task_rift(self, client):
		"""Return rift that automatically creates a task for each added coro."""
		async with Rift(name="_task_rift") as rift:
			async def _coros_to_tasks():
				# We use `start_with_copy=True` to include all coros added
				# before this point in time.
				coro_changes = self._coros.changes(start_with_copy=True)
				with to_agen(coro_changes, name="task_group._task_rift") as gen:
					async for diff in gen:
						# Currently, the implementation doesn't have a
						# `Rift.destroy_task`, so we are not expecting to
						# get any `diffs.RemoveValue` instances.
						assert isinstance(diff, diffs.AddValue), "All diffs must be AddValue"
						coro = diff.value
						rift.create_task(coro(client))
			rift.create_task(_coros_to_tasks())
			yield rift

	@asynccontextmanager
	async def _connected_client(self):
		"""Return a connected MQTT client.

		Retries until a connection can be made.
		"""
		options = {
			"logger": _LOGGER,
			"expected_exceptions": (MqttError,),
			"log_success_msg": "Connection established after {duration:.1f} second(s).",
			"log_error_msg_prefix": "Could not connect",
			"log_error_exc_info": False,
		}
		async with retry_context(self._client(), **options) as client:
			yield client

	def _client(self) -> Client:
		"""Return an unconnected MQTT client."""
		return Client(
			self._host,
			*self._args,
			client_id=self.client_id,
			**self._kwargs,
		)

	def cancel(self) -> None:
		self._rift.cancel()

	async def __aenter__(self) -> TaskGroup:
		await self._rift.__aenter__()
		self._rift.create_task(self._main())
		return self

	async def __aexit__(self, exc_type, exc_value, traceback) -> None:
		await self._rift.__aexit__(exc_type, exc_value, traceback)
