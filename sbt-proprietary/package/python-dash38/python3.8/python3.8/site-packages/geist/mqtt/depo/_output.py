from __future__ import annotations

import asyncio
import json
import logging
import sys

import rx
from rx import Observable
from rx import operators as ops
from rx.subject import Subject

from ...asyncio import Rift
from ...collections.observable import diffs
from ...rx.asyncio import to_agen
from .. import Client, PacketTypes, Properties
from ._task_barrier import task_barrier
from ._val import Val

_LOGGER = logging.getLogger(__name__)


class Output:
	"""Output from an `Observable` to a MQTT collection topic.

	Data flow: Observable -> MQTT collection topic
	"""

	def __init__(
		self,
		client: Client,
		depo_name: str,
		changes: Observable,
	) -> None:
		self._client = client
		self._depo_name = depo_name
		self._changes = changes
		self._rift = Rift(name="Output")

	async def _track_changes(self, ready):
		stop_signal = Subject()
		obs = self._changes.pipe(
			ops.take_until(stop_signal),
		)
		try:
			async def _process_changes():
				with to_agen(obs, name="output._track_changes") as diff_gen:
					ready()
					async for diff in diff_gen:
						topic = self._topic(diff)
						if isinstance(diff, diffs.SetItem):
							val = diff.value
							assert isinstance(val, Val), "diff.value must be an instance of depo.Val"
							# Only publish changes that we made ourselves. Otherwise, we may
							# needlessly re-publish changes from other clients. This can
							# lead to an inifinite publishing cycle between the clients.
							if val.metadata.last_modified_by != self._client.id:
								continue
							await self._set(topic, val.data)
						elif isinstance(diff, diffs.DelItem):
							await self._del(topic)
						else:
							raise RuntimeError(f"Invalid diff: {diff}")
			task = asyncio.create_task(_process_changes())
			await asyncio.shield(task)
		finally:
			# Don't allow more changes to be added to the queue. Any pending
			# changes will still be processed in the `_process_changes` task
			#
			# This ensures that any pending changes will get applied before
			# the connection is closed in the outer scope.
			stop_signal.on_next(None)
			stop_signal.on_completed()
			if not task.done():
				await task

	async def _set(self, topic: str, value) -> None:
		payload = json.dumps(value)
		properties = self._properties(last_modified_by=self._client.id)
		# _LOGGER.debug(f"publish SET: last_modified_by={self._client.id} topic={topic}")
		await self._client.publish(topic, payload, retain=True, qos=2, properties=properties)

	async def _del(self, topic: str) -> None:
		properties = self._properties(last_modified_by=self._client.id)
		# _LOGGER.debug(f"publish DEL: last_modified_by={self._client.id} topic={topic}")
		await self._client.publish(topic, bytes(), retain=True, qos=2, properties=properties)

	def _properties(self, **kwargs) -> Properties:
		properties = Properties(PacketTypes.PUBLISH)
		for name, value in kwargs.items():
			# It looks as if we are overriding the same property but
			# this is in fact adding a new "user property" for each
			# assignment to the `UserProperty` attribute.
			#
			# Reference: https://github.com/eclipse/paho.mqtt.python/blob/9a26243c347e5b212953e963f64e84836504351c/src/paho/mqtt/properties.py#L148
			properties.UserProperty = (name, value)
		return properties

	def _topic(self, diff: diffs.MapDiffs) -> str:
		return f"depo1/{self._depo_name}/{diff.key}"

	async def __aenter__(self) -> Output:
		await self._rift.__aenter__()
		try:
			# Wait until we are ready to iterate through the changes.
			# This ensures that the change detection is up and running at the
			# time that we enter this context manager.
			await task_barrier(self._rift, self._track_changes)
		except:
			# When an exception is raised in `__aenter__` then `__aexit__`
			# won't be called. Therefore, we do the cleanup here.
			if not await self._rift.__aexit__(*sys.exc_info()):
				raise
		return self

	async def __aexit__(self, exc_type, exc_value, traceback) -> None:
		await self._rift.__aexit__(exc_type, exc_value, traceback)


async def apply_changes(client: Client, depo_name: str, changes: diffs.MapDiffs) -> None:
	obs = rx.from_iterable(changes)
	async with Output(client, depo_name, obs):
		pass
