"""Sleep functions not found in the standard library (yet)."""
import asyncio
import logging
from contextlib import AbstractAsyncContextManager
from typing import Optional

from ._collect import collect

_LOGGER = logging.getLogger(__name__)


class Rift(AbstractAsyncContextManager):
	"""Context manager for asyncio tasks

	When you want to "fire and forget" asyncio tasks but don't actually
	want to "forget" them entirely.

	Inspired by the ideas of structured concurrency. Hopefully, we will
	see something similar in the Python specification itself some day.

	Think along the lines of Trio's "nursery" but with a smaller
	feature set.
	"""

	def __init__(self, *, name: Optional[str] = None) -> None:
		self._tasks = set()
		self._exception: Optional[BaseException] = None
		self._new_task = asyncio.Event()
		self._name = name  # For (debug) logging purposes

	def create_task(self, *args, **kwargs) -> asyncio.Task:
		"""Create a task that will be managed by this rift."""
		task = asyncio.create_task(*args, **kwargs)
		task.add_done_callback(self._on_task_done)
		self._tasks.add(task)
		self._signal_new_task()
		return task

	def cancel(self) -> None:
		"""Cancel all currently-running tasks."""
		for task in self._tasks:
			task.cancel()

	async def enter_context(self, manager):
		"""Enter the given context manager."""
		fut = asyncio.Future()
		async def _runner():
			# Enter
			try:
				result = await manager.__aenter__()
			except BaseException as exc:
				fut.set_exception(exc)
			else:
				fut.set_result(result)
			# Exit
			result = await manager.__aexit__(None, None, None)
		self.create_task(_runner())
		return await fut

	async def wait(self, *, return_when=asyncio.ALL_COMPLETED) -> None:
		"""Wait for the tasks in this rift.

		Waits for both tasks that are:
		  * Currently in this rift
		  * Added to this rift during this wait

		Does not raise any exceptions.

		Simply waits for the tasks and doesn't:
		  * Raise exceptions
		  * Cancel any tasks
		"""
		while True:
			if not self._tasks:
				return
			wait_for_tasks = asyncio.wait(self._tasks, return_when=return_when)
			# Wait until either:
			#  1. The task wait is over.
			#  2. A new task was added to this rift.
			done, _ = await collect(
				wait_for_tasks,  # [1]
				self._new_task.wait(),  # [2]
				return_when=asyncio.FIRST_COMPLETED
			)
			# Only return when the tasks are done [1]. If not, we reached this
			# point because a new task was added to this rift [2].
			if wait_for_tasks in done:
				return

	def _on_task_done(self, task: asyncio.Task):
		# Retrieve task exception. This also has the side effect
		# of marking the exception as retrieved.
		try:
			task_exc = task.exception()
		except asyncio.CancelledError as error:
			task_exc = error
		# We store the task's exception in this callback. Note that while
		# multiple tasks may raise an exception, we only store a single
		# exception. This is because it is difficult to raise "multi
		# exceptions" in python (use Trio if you need this).
		#
		# We prioritize `CancelledError` lowest since other exceptions
		# are usually more informative.
		if self._exception is None or isinstance(self._exception, asyncio.CancelledError):
			# By design, Task.exception will raise an
			# asyncio.CancelledError if the task is cancelled.
			# We also want to propagate asyncio.CancelledError,
			# so we catch it here.
			self._exception = task_exc
		self._tasks.remove(task)

	def _signal_new_task(self) -> None:
		"""Signal that a new task was recently added to this rift."""
		# This will wake up all current calls to `Rift.wait` (if any)
		# and allow said calls to take the newly added task into account.
		#
		# `asyncio.Event.set` docs:
		# > All tasks waiting for event to be set will be immediately awakened.
		self._new_task.set()
		self._new_task.clear()

	async def __aenter__(self):
		return self

	async def __aexit__(self, exc_type, exc_value, traceback):
		"""Wait for all the tasks to complete.

		Raise the exception of a task (if any)

		We don't try to solve the problem of raising a "multi exception"
		of all the tasks' combined exceptions. Instead, we simply
		raise the exception of an arbitrary task.
		"""
		if exc_type is not None:
			# We are exitting this rift due to a raised exception.
			# Cancel all tasks so that the exception is not delayed
			# at the `collect` call.
			self.cancel()

		# Wait for the first task that throws an exception or until
		# all tasks complete normally.
		#
		# We use `collect` to ensure that when we leave the rift, all
		# tasks are done (completed, failed, or cancelled).
		#
		# Had we used, e.g., `asyncio.gather` instead, there might still
		# have been pending tasks. From `asyncio.gather` docs:
		#  > If return_exceptions is False (default), the first raised
		#  > exception is immediately propagated to the task that awaits
		#  > on gather(). Other awaitables in the aws sequence wonâ€™t be
		#  > cancelled and will continue to run.
		#
		# Even though it says "return on `FIRST_EXCEPTION`"", it will
		# also wait for all tasks if no exception occurs. Docs for
		# `return_when`:
		#  > The function will return when any future finishes by raising
		#  > an exception. If no future raises an exception then it is
		#  > equivalent to ALL_COMPLETED.
		await collect(*self._tasks, return_when=asyncio.FIRST_EXCEPTION)
		# Propagate an exception (if any)
		if self._exception is not None:
			raise self._exception
