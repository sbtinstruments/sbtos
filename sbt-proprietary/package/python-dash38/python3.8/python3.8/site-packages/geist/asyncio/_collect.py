"""Sleep functions not found in the standard library (yet)."""
import asyncio
from typing import Awaitable, Mapping, Set, Tuple

TaskMap = Mapping[Awaitable, asyncio.Task]


async def collect(
	*aws: Awaitable,
	return_when: str = asyncio.ALL_COMPLETED,
	cancel_pending: bool = True,
) -> Tuple[TaskMap, TaskMap]:
	"""Run the given `Awaitable`s concurrently.

	Python's `asyncio` comes with two built-in task-gathering functions:
	  1. The high-level `asyncio.gather`
	  2. The low-level `asyncio.wait`

	`collect` is situated right in-between `asyncio.gather` and
	`asyncio.wait`. Use `collect` when you need the `return_when`
	keyword (known from `asyncio.wait`) but also want cancellation
	and automatic scheduling (known from `asyncio.gather`).

	Cancellation is an especially important distinction between
	the various functions:
	  * `asyncio.gather` will *not* cancel the pending tasks if an
	    exception is raised in a task (including `CancelledError`)
	  * `asyncio.gather` will cancel the tasks if the call to
	    `gather` itself is cancelled
	  * `collect` will cancel the pending tasks if an exception is
	    raised in a task (including `CancelledError`) *and*
	    `cancel_pending=True`
	  * `collect` will cancel the tasks if the call to `collect`
	    itself is cancelled *and* `cancel_pending=True`
	  * `asyncio.wait` will never cancel the tasks

	Likewise, automatic scheduling also depends on the function:
	  * `asyncio.gather` will automatically schedule coroutines
	  * `collect` will automatically schedule coroutines
	  * `asyncio.wait` will not automatically schedule coroutines
	    but this used to be the case until it was deprecated in
		Python 3.8

	The final distinction is in the return type:
	  * `asyncio.gather` returns a list of results (including
	    exceptions if `return_exceptions=True`)
	  * `collect` returns a tuple of task maps: one map for pending
	    tasks and one map for done tasks.
	  * `asyncio.wait` returns a tuple task sets: one set for
	    pending tasks and one set for done tasks.

	`collect` returns a tuple of done and pending maps. This fixes
	one of the shortcomings of `asyncio.wait`. It allows you to do
	the following (which you can't do with `asyncio.wait`):

		async def foo():
			return 42

		coro = foo()
		done, pending = await collect(coro)

		if coro in done:
			# We enter here.
	"""
	# Early out if given empty iterable
	if not aws:
		return {}, {}
	task_map = {aw: _ensure_awaitable(aw) for aw in aws}
	tasks = set(task_map.values())
	try:
		done, pending = await asyncio.wait(tasks, return_when=return_when)
	finally:
		if cancel_pending:
			# We can end up in the finally clause due to various reasons:
			#  * Try clause succeeds
			#  * `asyncio.Cancelled`, `KeyboardInterrupt`, or other `BaseException`s
			# Therefore, we can't rely on `pending` to be defined.
			# Instead, we simply generate a new `pending` iterable.
			pending = [task for task in tasks if not task.done()]
			for task in pending:
				task.cancel()
			if pending:  # `asyncio.wait` doesn't like empty lists
				# Wait until the pending tasks are cancelled
				await asyncio.wait(pending)
	done_map = _intersect(task_map, done)
	pending_map = _intersect(task_map, pending)
	return done_map, pending_map

def _intersect(task_map: TaskMap, set_: Set[asyncio.Task]):
	return {
		aw: task for aw, task in task_map.items()
		if task in set_
	}

def _ensure_awaitable(aw: Awaitable) -> asyncio.Task:
	if isinstance(aw, asyncio.Task):
		# Early out. No need to double-wrap a task
		return aw
	return asyncio.create_task(aw)
