import asyncio
import itertools
import logging
import sys
from contextlib import asynccontextmanager
from time import time
from typing import Awaitable, Callable, Optional, Tuple, TypeVar

_LOGGER = logging.getLogger(__name__)

RT = TypeVar("RT")

DelayFunc = Callable[[int], float]  # Iteration (0, 1, 2, ...) -> Delay in seconds

DEFAULT_DELAY_FUNC = lambda i: 2 ** i  # 1, 2, 4, 8, ...

DEFAULT_LOG_MSG = (
	"Failed due to {error}. "
	"Will retry in {delay} seconds. "
	"This was failure number {iteration}."
)

class RetriesExhausted(Exception):
	"""All retry attempts are used up."""


@asynccontextmanager
async def retry_context(context_manager, **kwargs):
	"""Keep entering the context manager until it succeeds."""
	result = await retry(context_manager.__aenter__, **kwargs)
	# The following is equivalent to an async with statement.
	# See: https://www.python.org/dev/peps/pep-0492/#new-syntax
	try:
		yield result
	except:  # pylint: disable=bare-except
		if not await context_manager.__aexit__(*sys.exc_info()):
			raise
	else:
		await context_manager.__aexit__(None, None, None)


async def retry(
	coro: Callable[[], Awaitable[RT]],
	*args,
	delay_func: DelayFunc = DEFAULT_DELAY_FUNC,
	max_iterations: Optional[int] = None,
	logger: Optional[logging.Logger] = None,
	log_success_level: int = logging.INFO,
	log_success_msg: Optional[str] = None,
	log_error_level: int = logging.WARNING,
	log_error_msg: str = DEFAULT_LOG_MSG,
	log_error_msg_prefix: Optional[str] = None,
	log_error_exc_info: bool = True,
	expected_exceptions: Tuple[BaseException] = (Exception,)
) -> Awaitable[RT]:
	"""Keep calling the given function until it succeeds."""
	start_time = time()
	# Resolve defaults
	if logger is None:
		logger = _LOGGER
	if max_iterations is None:
		iterations = itertools.count()  # Infinite range
	else:
		iterations = range(max_iterations)
	# Retry loop
	#
	# Keep iterating until:
	#  * The coroutine function succeeds or fails
	#  * The max iteration count is reached (if any)
	for iteration in iterations:
		try:
			# Attempt to execute the coroutine
			result = await coro(*args)
			# If we got this far, the attempt was successful. Let's
			# break the loop so that we can log the success and return
			# the coroutine result.
			break
		except expected_exceptions as error:
			# An error occurred. Let's log it (optional) and try to
			# execute the coroutine again after a delay.
			# The default delay function increases exponentionally.
			# This way, we avoid needlessly stressing a system that
			# might already struggle to execute the coroutine.
			delay = delay_func(iteration)
			duration = time() - start_time
			msg = log_error_msg.format(
				error=_format_exc(error),
				delay=delay,
				iteration=iteration,
				duration=duration,
			)
			if log_error_msg_prefix is not None:
				msg = f"{log_error_msg_prefix}. {msg}"
			logger.log(log_error_level, msg)
			if log_error_exc_info:
				logger.debug("Reason:", exc_info=error)
			await asyncio.sleep(delay)
	else:  # We did not hit a `break` statement
		raise RetriesExhausted()
	# If we got this far, the coroutine executed successfully.
	# Let's log the success (optional) and return the result.
	if log_success_msg is not None:
		duration = time() - start_time
		msg = log_success_msg.format(duration=duration)
		logger.log(log_success_level, msg)
	return result


def _format_exc(exc: Exception) -> str:
	"""Return a string representation of the given exception.

	For example, the exception:
		RuntimeError("A task is already running")
	becomes the string:
		'RuntimeError: "A task is already running"'

	Likewise, the exception:
		RuntimeError()
	becomes the string
		'RuntimeError'
	"""
	exc_name = type(exc).__name__
	exc_str = str(exc)
	if exc_str:
		return f'{exc_name}: "{exc_str}"'
	return exc_name
