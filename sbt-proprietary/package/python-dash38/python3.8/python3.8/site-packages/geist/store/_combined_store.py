"""Store that combines the state of sub-stores into one state."""
from ._store import Store


class CombinedStore(Store):
	"""Store with combined state of sub-stores.

	Note that this store is more like a multidict.MultiDict than a dict. This is because
	it may have several values for the same key.
	"""

	def __init__(self, substores):
		"""Construct store with state from the given sub-store sequence."""
		self._substores = substores

	def get_path(self, key):
		"""Get path corresponding to key from the first sub-store that accepts this operation.

		Raises TypeError if no sub-stores accepts the 'get_path' operation.
		"""
		for store in self._substores:
			try:
				return store.get_path(key)
			# KeyError is raised when the given key is not in the store.
			# ValueError is raised for 'invalid' paths. E.g., paths that points to the
			# wrong file type.
			except (KeyError, ValueError):
				pass
		raise KeyError(f'No sub-store could retrieve a path for the key "{key}".')

	def _del_from_others(self, store, key):
		"""Delete given key from all sub-stores except the given store.

		Skips sub-stores where the delete operation is not successful.
		"""
		for other in self._substores:
			if other is store:
				continue
			try:
				del other[key]
			# Ignore sub-stores that:
			# * don't have the key (KeyError)
			# * are in read-only mode (TypeError)
			except (KeyError, TypeError):
				pass

	def __delitem__(self, key):
		"""Delete entry with the given key from all sub-stores where that is possible.

		Entries from read-only sub-stores are not removed.
		Raises a KeyError if the given key was not found in any of the sub-stores.
		"""
		no_deletes = True
		for store in self._substores:
			try:
				store.__delitem__(key)
				no_deletes = False
			# Ignore sub-stores that:
			# * don't have the key (KeyError)
			# * are in read-only mode (TypeError)
			except (KeyError, TypeError):
				pass
		if no_deletes:
			raise KeyError

	def __getitem__(self, key):
		"""Get entry with the given key from the first sub-store that accepts the operation."""
		for store in self._substores:
			try:
				return store.__getitem__(key)
			except KeyError:
				pass
		raise KeyError

	def __setitem__(self, key, value):
		"""Set given key to given value in the first sub-store that accepts the operation.

		Removes entries with the given key from the other sub-stores where that is possible.
		E.g., keys are not removed from read-only sub-stores.
		"""
		for store in self._substores:
			try:
				store.__setitem__(key, value)
				self._del_from_others(store, key)
				return
			except (KeyError, ValueError, TypeError):
				pass
		raise Exception(f'Unable to set key "{key}" to the given value in any of the sub-stores.')

	def __iter__(self):
		"""Iterate over all keys in the sub-store sequence.

		Note that duplicate keys may occur (when two or more sub-stores have identical keys).
		"""
		for store in self._substores:
			for key in store.__iter__():
				yield key

	def __len__(self):
		"""Return the total length of the sub-store sequence."""
		return sum(len(store) for store in self._substores)

	def __enter__(self):
		"""Open sub-stores that require it."""
		for store in self._substores:
			try:
				store.__enter__()
			except AttributeError:
				pass
		return self

	def __exit__(self, *args, **kwargs):
		"""Close sub-stores that require it."""
		for store in self._substores:
			try:
				store.__exit__(*args, **kwargs)
			except AttributeError:
				pass
