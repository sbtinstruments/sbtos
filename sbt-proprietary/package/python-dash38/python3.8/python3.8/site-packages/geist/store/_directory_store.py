"""Store with state in the file system."""
import re
import os
from pathlib import Path
from ._store import Store


class DirectoryStore(Store):
	"""Store with file system-based state management and an entry point in a given directory."""

	def __init__(self, directory, *, types, read_only=False):
		"""Construct store with state mapped to directory."""
		self._data_directory = Path(directory)
		self._data_directory.mkdir(exist_ok=True, parents=True)
		self._types = types
		self._read_only = read_only

	def get_path(self, key):
		"""Get the full path corresponding to the given file name.

		Raises KeyError if the key does not correspond to a file in the directory.
		"""
		path = self._data_directory / key
		if not path.is_file():
			raise KeyError(f'No key "{key}" in store.')
		self._validate_path(path)
		return path

	def stats(self):
		"""Return a dict with a stat object corresponding to each file in the directory.

		The underlying implementation is based on the os.scandir call for performance reasons.
		"""
		# Regular expression to match the store's file types.
		types = "|".join(self._types)
		rexp = re.compile(f'^.*\.({types})$')
		# An entry is a directory, file, symbolic link, etc.
		with os.scandir(self._data_directory) as entries:
			# We are only interested in files.
			files = (e for e in entries if e.is_file())
			# Specifically, files of the store's file types.
			valid_files = (f for f in files if rexp.match(f.name))
			# We do a stat call for each file. This can take a lot of time depending
			# on how many files there are.
			return {f.name: f.stat() for f in valid_files}

	def _validate_path(self, path):
		data_type = "".join(path.suffixes)[1:]  # E.g.: "/path/to/file/test.bbp.json" -> "bbp.json"
		if data_type not in self._types:
			raise ValueError(f'Invalid file type "{data_type}"')

	def _keys(self):
		"""Return the name of all files currently in the directory.

		Filters out files of the wrong type. Directories are ignored.
		"""
		result = []
		for type_ in self._types:
			subresult = (f.name for f in self._data_directory.glob(f'*.{type_}') if f.is_file())
			result.extend(subresult)
		return result

	def __delitem__(self, key):
		"""Delete a file in the directory with the given name."""
		if self._read_only:
			raise TypeError("'__delitem__' is unsupported in read-only mode.")
		path = self.get_path(key)
		try:
			path.unlink()
		except OSError as error:
			raise KeyError(f'No key "{key}" in store.') from error

	def __getitem__(self, key):
		"""Get a path to a file in the directory with the given name."""
		return self.get_path(key)

	def __setitem__(self, key, value):
		"""Create a file in the directory with the given name and contents.

		Overrides existing files.
		"""
		if self._read_only:
			raise TypeError("'__setitem__' is unsupported in read-only mode.")
		path = self._data_directory / key
		self._validate_path(path)
		try:
			with path.open(mode='wb') as f:
				try:
					# Value may be None to create an empty file.
					if value is not None:
						f.write(value)
				except OSError as error:
					raise ValueError('Unable to write given value to file.') from error
		except OSError as error:
			raise KeyError(f'File corresponding to key "{key}" cannot be opened.') from error

	def __iter__(self):
		"""Iterate over all file names in the directory.

		Filters out files of the wrong type. Directories are ignored.
		"""
		for key in self._keys():
			yield key

	def __len__(self):
		"""Get the number of files in the directory.

		Filters out files of the wrong type. Directories are ignored.
		"""
		return len(self._keys())

	def __enter__(self):
		"""Do nothing. At some point, this may open a handle to the directory."""
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		"""Do nothing."""
