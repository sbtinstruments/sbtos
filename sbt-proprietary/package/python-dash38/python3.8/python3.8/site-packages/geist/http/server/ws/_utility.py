"""Makes aiohttp easier to use."""
from time import time
from aiohttp import web, WSCloseCode
from ._websocket_writer import SyncWebSocketWriter
from ....asyncio import sleep_until


async def close_websockets(app):
	"""Close all websocket connections found in the application.

	Unified websocket closing logic for aiohttp applications.

	Reference: https://aiohttp.readthedocs.io/en/stable/web_advanced.html#graceful-shutdown
	"""
	for ws in set(app['websockets']):
		await ws.close(code=WSCloseCode.GOING_AWAY, message='Server shutdown')


def is_websocket_request(request):
	"""Use in an aiohttp request handler to switch between regular GET requests and WS requests."""
	upgrade = request.headers.get('UPGRADE')
	return upgrade and 'websocket' == upgrade.lower()



def websocket_only(handler):
	"""Use in an aiohttp request handler to return an error for non-websocket requests."""
	async def _wrapper(self, request):
		if not is_websocket_request(request):
			text = 'Only websocket connections are allowed.'
			headers = {'Upgrade': 'websocket'}
			raise web.HTTPUpgradeRequired(text=text, headers=headers)
		return await handler(self, request)
	return _wrapper


def ws_or_json(*,
               websocket_writer=SyncWebSocketWriter,
               websocket_period=None,
               websocket_wrap_value=True):
	def _decorator(coro):
		async def _wrapper(self, request, *args, **kwargs):
			# Regular HTTP response
			if not is_websocket_request(request):
				return web.json_response(await coro(self, request, *args, **kwargs))
			# WebSocket response
			async def _get_values_sync():
				if isinstance(websocket_writer, SyncWebSocketWriter):
					# Discard the initialization message (we don't need it)
					yield
				# Yield a result periodically
				while True:
					start = time()
					try:
						value = await coro(self, request, *args, **kwargs)
					except web.HTTPException as error:
						yield {'error': str(error)}
					else:
						# For legacy reasons, we sometimes return the raw value directly.
						# In the future, this should not be an option. All values should
						# be wrapped so that we can distinguish errors from values.
						if websocket_wrap_value:
							value = {'value': value}
						yield value
					# For the WebSocketWriter, we may want to wait a bit to avoid spamming
					# values over the line.
					if websocket_period is not None:
						await sleep_until(start + websocket_period)
			wsw = websocket_writer(request)
			return await wsw.handler(_get_values_sync())
		return _wrapper
	return _decorator
