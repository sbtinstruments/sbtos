"""Useful utilities and defaults for aiohttp websocket communication."""
import asyncio
import logging
import async_timeout
from aiohttp import web, WSMsgType
from .._request_logger import RequestLogger


_LOGGER = logging.getLogger(__name__)


class WebSocketWriterBase:
	"""Links an asynchronous iterable to a websocket stream.

	Override the _handler method in a derived class.
	"""

	def __init__(self,
	             request,
	             *,
	             compress=False):
		"""Construct WebSocket writer from the given request."""
		self.request = request
		self.request['logger'] = RequestLogger(_LOGGER, request)
		self._compress = compress

	async def handler(self, asynciterable):
		"""Use as the request handler in an aiohttp response."""
		ws = web.WebSocketResponse(heartbeat=20.0,
		                           compress=self._compress)
		ws['logger'] = self.request['logger']
		# ws.can_prepare will never throw by itself
		if not ws.can_prepare(self.request):
			ws['logger'].warning('Can not prepare request. Closing connection.')
			raise web.HTTPBadRequest()
		# ws.prepare is guaranteed to succeed if .can_prepare returns true
		await ws.prepare(self.request)
		# Register websocket connection
		websockets = self.request.app['websockets']
		websockets.add(ws)
		try:
			await self._handler(ws, asynciterable)
		except asyncio.CancelledError:
			pass
		except Exception as error:  # pylint: disable=broad-except
			ws['logger'].warning((f'An error occurred during serving: "{error}". '
			                     'Closing connection.'))
			ws['logger'].debug('Reason:', exc_info=error)
		finally:
			# Close WebSocket.
			try:
				await ws.close()
			except Exception as error:  # pylint: disable=broad-except
				ws['logger'].error(f'Error closing WebSocket: "{error}".')
				ws['logger'].debug('Reason:', exc_info=error)
			# Unregister websocket connection
			websockets.discard(ws)
		return ws

	async def _handler(self, ws, asynciterable):
		raise NotImplementedError

	@staticmethod
	async def _send(ws, data, *, compress=None, timeout=20.0):
		# We need to explicitly check if the transport is closing.
		# See: https://github.com/aio-libs/aiohttp/issues/2309
		if ws._req.transport is None:  # pylint: disable=protected-access
			raise RuntimeError('Transport is gone.')
		if ws._req.transport.is_closing():  # pylint: disable=protected-access
			raise RuntimeError('Transport is closing.')
		# Wrap send in timeout.
		# The timeout ensures that all write tasks will eventually end.
		# Even those left lingering by a closing transport.
		# See: https://github.com/aio-libs/aiohttp/issues/2310
		async with async_timeout.timeout(timeout):
			# Switch on data type
			if isinstance(data, (bytes, bytearray, memoryview)):
				await ws.send_bytes(data, compress=compress)
			elif isinstance(data, str):
				await ws.send_str(data, compress=compress)
			elif isinstance(data, (dict, list)):
				await ws.send_json(data, compress=compress)
			else:
				raise ValueError(f'Can not send data of type {type(data)}')


class WebSocketWriter(WebSocketWriterBase):
	"""Sends all values from an asynchronous iterable over a websocket stream.

	All messages received over the websocket connection are ignored (except for error messages;
	those are logged).
	"""

	async def _handler(self, ws, asynciterable):
		write = WebSocketWriter._write(ws, asynciterable)
		write_task = asyncio.create_task(write)
		read = WebSocketWriter._read(ws)
		read_task = asyncio.create_task(read)
		tasks = [write_task, read_task]
		try:
			await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
		finally:
			first_error = None
			for task in tasks:
				task.cancel()
				try:
					await task
				except asyncio.CancelledError:
					pass
				except Exception as error:  # pylint: disable=broad-except
					if first_error is None:
						first_error = error
			if first_error is not None:
				raise first_error  # pylint: disable=raising-bad-type

	@staticmethod
	async def _read(ws):
		# Note that this loop is necessary for aiohttp to handle ping/ping mechanics internally.
		# The loop exits when the stream is closed (e.g., by the writer)
		async for msg in ws:
			# Break on error messages. All other messages are ignored.
			if WSMsgType.ERROR == msg.type:
				ws['logger'].warning(f'Error given by message: {msg.data}')
				ws['logger'].debug('Reason:', exc_info=msg.data)
				break

	@staticmethod
	async def _write(ws, asynciterable):
		try:
			async for data in asynciterable:
				await WebSocketWriter._send(ws, data)
		finally:
			await ws.close()


class SyncWebSocketWriter(WebSocketWriterBase):
	"""For each received websocket message, a value from the asynchronous generator is sent back.

	Communication diagram:

	  client               server           asyncgenobj
	    |                    |                   |
	    |                    | ---__anext__()--> | ---> Run to      :  [1] msg = yield
	    |                    |                   |      Pause
	    |                    |                   |
	    | ---ws.receive()--> | ---asend(msg)---> | --.
	    |                    |                   |    | Receive msg :  [1] msg = yield
	    |                    |                   |    | Run to      :  [2] msg = yield res
	    |                    |                   |    | Send res    :  [2] msg = yield res
	    |                    |                   |    | Pause
	    | <--ws.send(res)--- | <--res----------- | <-´
	    | ---ws.recieve()--> | ---asend(msg)---> | --.
	    |                    |                   |    | Receive msg :  [2] msg = yield res
	    |                    |                   |    | Run to      :  [3] msg = yield res
	    |                    |                   |    | Send res    :  [3] msg = yield res
	    |                    |                   |    | Pause
	    | <--ws.send(res)--- | <--res----------- | <-´
	    | ---ws.receive()--> | ---asend(msg)---> | --.
	    |                    |                   |    | Receive msg :  [3] msg = yield res
	    |                    |                   |    | Run to      :  [4] msg = yield res
	    |                    |                   |    | Send res    :  [4] msg = yield res
	    |                    |                   |    | Pause
	    | <--ws.send(res)--- | <--res----------- | <-´
	    |                    |                   |

	The first message may carry instructions on how the result should be formatted. Therefore,
	the asyncgenobj must recieve the message before it produces a result. To accomplish this,
	we don't expect the asyncgenobj to yield a result on the first yield statement.

	If the communication fails, the failure is logged and the connection is closed.
	"""

	async def _handler(self, ws, asyncgenobj):  # pylint: disable=arguments-differ
		"""Note that an asyncgenobj is required instead of an asynciterable."""
		# Start the asyncgenobj. The asyncgenobj will:
		#   1. Run to the first yield statement
		#   2. Send us the yielded value (usually None)
		#   3. Pause
		await asyncgenobj.__anext__()  # We discard the None value
		# Send a single response for each incoming message.
		async for msg in ws:
			# Break on error messages.
			if self._is_error(ws, msg):
				break
			# We received a message, so now the async generator must produce a
			# result. The received message is forwarded to the async generator.
			# The asyncgenobj will:
			#   1. Receive the msg
			#   2. Run to the next yield statement
			#   3. Send us the yielded value (our result)
			#   4. Pause
			result = await asyncgenobj.asend(msg.json())
			# This result is sent over the websocket.
			await WebSocketWriterBase._send(ws, result)

	def _is_error(self, ws, msg):
		if WSMsgType.ERROR == msg.type:
			ws['logger'].warning(f'Error given by message: {msg.data}')
			ws['logger'].debug('Reason:', exc_info=msg.data)
			return True
		return False
