"""Config HTTP interface handlers."""
import logging
import jmespath
import jmespath.exceptions
import jsonpatch
from aiohttp import web
from jsonschema import ValidationError
from ....app import ConfigError


_LOGGER = logging.getLogger(__name__)


class ConfigHandler:
	"""Convenience class with config handlers as methods."""

	def __init__(self, app):
		"""Construct from the given aiohttp application."""
		self._config = app['config']

	async def get_config(self, request):
		"""Return the (partial) config as a JSON document.

		Examples:
		* /config                            -> Returns everything: {...}
		* /config?jmespath_expr=system       -> Returns debug setting: { "value": system: {...} }
		* /config?jmespath_expr=system.debug -> Returns debug setting: { "value": true }

		"""
		config_dict = self._config.to_dict()
		jmespath_expr = request.query.get('jmespath_expr')
		# Return the enture config if there is no given JMESPath expression.
		if jmespath_expr is None:
			return web.json_response(config_dict)
		# Return subconfig.
		try:
			result = jmespath.search(jmespath_expr, config_dict)
		except jmespath.exceptions.JMESPathError as error:
			raise web.HTTPBadRequest(text=error)
		return web.json_response({'value': result})

	async def patch_config(self, request):
		"""Modify the config and save it."""
		patch = await request.json()
		config_dict = self._config.to_dict()
		try:
			modified_config_dict = jsonpatch.apply_patch(config_dict, patch)
		except jsonpatch.JsonPatchException as error:
			raise web.HTTPBadRequest(text=error)
		# jsonpatch does not convert all exceptions into JsonPatchException's.
		# For instance, the following patch raises KeyError
		#   [
		#     {
		#       "op": "add"
		#     }
		#   ]
		# because there is no "path" key.
		# Issue: https://github.com/stefankoegl/python-json-patch/issues/88
		except KeyError as error:
			raise web.HTTPBadRequest(text=f'Unable to apply JSON Patch: Missing key {error}')
		# Because of the above, I'm afraid that other Exceptions may escape jsonpatch.
		# We just catch all Exception's here to be sure.
		except Exception as error:
			raise web.HTTPBadRequest(text=f'Unable to apply JSON Patch: {error}')
		# Validate the patched config dict.
		try:
			self._config.validate(modified_config_dict)
		except ValidationError as error:
			error_path = '' if not error.path else f'{str(list(error.path))}: '
			raise web.HTTPBadRequest(text=f'{error_path}{error.message}')
		# Apply the patch again but this time in place. This ensures that all currently running
		# submodules will see the changes. Alternatively, the current config dict could be overriden
		# with the already patched config dict. This would be more performant but the submodules
		# would not see the changes, which is undesirable.
		jsonpatch.apply_patch(config_dict, patch, in_place=True)
		# Save changes.
		try:
			self._config.save()
		except ConfigError as error:
			raise web.HTTPConflict(text=error)
		raise web.HTTPNoContent
