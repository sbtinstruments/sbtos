from contextlib import AbstractContextManager
import logging


_LOGGER = logging.getLogger(__name__)


class suppress(AbstractContextManager):
	"""Context manager to suppress specified exceptions
	After the exception is suppressed, execution proceeds with the next
	statement following the with statement.
		with suppress(FileNotFoundError) as sup:
			os.remove(somefile)
		# Execution still resumes here if the file was already removed
		# We can return the exception
		if sup.exception is not None and return_exceptions:
			return sup.exception

	Note that the suppressed exception is stored so that it can be easily
	returned.

	Based on contextlib.suppress
	"""

	def __init__(self, *exceptions):
		# Unlike contextlib.suppress, we also support passing in None.
		self._exc_types = tuple(exc for exc in exceptions if exc is not None)
		self.exception = None

	def __enter__(self):
		return self

	def __exit__(self, exctype, excinst, exctb):
		# Unlike isinstance and issubclass, CPython exception handling
		# currently only looks at the concrete type hierarchy (ignoring
		# the instance and subclass checking hooks). While Guido considers
		# that a bug rather than a feature, it's a fairly hard one to fix
		# due to various internal implementation details. suppress provides
		# the simpler issubclass based semantics, rather than trying to
		# exactly reproduce the limitations of the CPython interpreter.
		#
		# See http://bugs.python.org/issue12029 for more details
		should_suppress = exctype is not None and issubclass(exctype, self._exc_types)
		if should_suppress:
			self.exception = excinst
		return should_suppress
