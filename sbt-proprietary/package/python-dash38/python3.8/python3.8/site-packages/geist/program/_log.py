import logging
from contextlib import contextmanager
from ..time import DurationTimer


_LOGGER = logging.getLogger(__name__)


class ProgramLog:
	def __init__(self, execution):
		self._execution = execution

	def debug(self, *args, **kwargs):
		self._log(logging.DEBUG, *args, **kwargs)

	def info(self, *args, **kwargs):
		self._log(logging.INFO, *args, **kwargs)

	def warning(self, *args, **kwargs):
		self._log(logging.WARNING, *args, **kwargs)

	def error(self, *args, **kwargs):
		self._log(logging.ERROR, *args, **kwargs)

	@contextmanager
	def duration(self, *, name=None, expected=None):
		try:
			with DurationTimer() as dt:
				yield dt
		finally:
			elapsed = dt.elapsed.total_seconds()
			if expected is not None:
				delta = elapsed - expected
				if delta > 0:
					# Missed the mark
					self.warning(f'Took {elapsed:.2f} s (was {delta:.2f} s slower than the '
					             f'expected duration of {expected:.2f} s).', name=name)
				else:
					# Hit the mark
					self.info(f'Took {elapsed:.2f} s (was {-delta:.2f} s faster than the '
					          f'expected duration of {expected:.2f} s).', name=name)
			else:
				self.info(f'Took {elapsed:.2f} s.', name=name)

	def _log(self, level, message, *, name=None, exc_info=None):
		hint = self._hint(name=name)
		_LOGGER.log(level, f'[{hint}] {message}', exc_info=exc_info)

	def _hint(self, *, name=None):
		if self._execution.current_section is not None:
			section_name = self._execution.current_section.name
		else:
			section_name = None
		names = [self._execution.name, section_name, name]
		return ':'.join(name for name in names if name is not None)
