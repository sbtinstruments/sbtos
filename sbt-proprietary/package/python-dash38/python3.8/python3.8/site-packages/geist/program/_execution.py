from asyncio import iscoroutine
from ._error import ProgExecError
from ._section import ProgramSection, ProgramSections
from ._log import ProgramLog
from ..task import Task


class ProgramExecution(Task):
	def __init__(self, name, byte_code, globals_, pre_exec_hooks):
		"""Construct program execution.

		The given globals will be shallow-copied.
		"""
		super().__init__(self._execute)
		self._name = name
		self._byte_code = byte_code
		self._pre_exec_hooks = pre_exec_hooks
		self._log = ProgramLog(self)
		self._sections = ProgramSections(self._log)
		self._main = None
		self._globals = {
			**globals_,  # Shallow copy
			'section': self._sections.section,
			'log': self._log,
			'run': self._run,
		}

	@property
	def name(self) -> str:
		return self._name

	@property
	def globals(self) -> dict:
		return self._globals

	@property
	def current_section(self) -> ProgramSection:
		return self._sections.current

	def reset(self):
		raise NotImplementedError()

	async def _execute(self):
		# Environment
		try:
			# Run any registered hooks
			for pre_exec_hook in self._pre_exec_hooks:
				await pre_exec_hook(self)
			# Execute the program code. Usually, this registers a main coroutine
			# that is awaited in a subsequent step.
			#
			# Note that we only specify exec's 'globals' argument and not the 'locals'
			# argument. This will use the same dict for both 'locals' and 'globals'.
			# In turn, the code executes as if it was at module level.
			# Had we used a different dict for the 'locals' argument, the code would
			# execute as if it was embedded in a class definition. Consequently, we
			# wouldn't be able to call functions defined outside the main coroutine.
			#
			# Reference: https://docs.python.org/3/library/functions.html#exec
			exec(self._byte_code, self._globals)  # pylint: disable=exec-used
			# Ensure that the main coroutine is of the right format
			self._check_main()
			# Await the program's main coroutine
			await self._main
		except Exception as error:
			raise ProgExecError(str(error)) from error

	def _run(self, coro) -> None:
		if self._main is not None:
			raise RuntimeError('Only a single coroutine can be run during program execution.')
		if not iscoroutine(coro):
			raise ValueError('Can only run coroutine objects.')
		self._main = coro

	def _check_main(self):
		"""Raise ProgExecError if anything is wrong with the main coroutine."""
		if self._main is None:
			raise RuntimeError("The program is required to call 'run' once.")
