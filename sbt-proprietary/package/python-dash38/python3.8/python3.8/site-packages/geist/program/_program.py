"""Arbitrary Python program for 'code as data' purposes."""
import ast
import asyncio
import logging
import math
from dataclasses import is_dataclass
from contextlib import AsyncExitStack
from pathlib import Path
from RestrictedPython import compile_restricted_exec, safe_builtins, RestrictingNodeTransformer
from RestrictedPython.Guards import full_write_guard
from ._error import ProgCompError, ProgExecError
from ._execution import ProgramExecution


_LOGGER = logging.getLogger(__name__)


class Program():
	"""A 'restricted' python program for 'code as data' purposes.

	Note that while we attempt to 'restrict' the Python program this restriction is not
	considered bullet proof. Malicious users will still be able to write programs that can take over
	the system. However, said users must be explicit about their malicious intents in the
	'restricted' programs.
	"""

	def __init__(self,
	             source_code: str,
	             *,
	             file_name=None):
		"""Construct program from the given source code."""
		if file_name is None:
			file_name = '<string>'
		try:
			compilation = compile_restricted_exec(source_code,
			                                      filename=file_name,
			                                      policy=_ProgramNodeTransformer)
		except SyntaxError as error:
			raise ProgCompError(f'Line {error.lineno}: {error.text}') from error
		self._byte_code = compilation.code
		if compilation.errors:
			raise ProgCompError(compilation.errors[0])
		self._compilation_warnings = compilation.warnings
		self._file_name = file_name
		self._globals = {
			'AsyncExitStack': AsyncExitStack,
			'CancelledError': asyncio.CancelledError,
			'sleep': asyncio.sleep,
			'gather': asyncio.gather,
			'math': math,
			# TODO: Use guarded versions of min/max from ZopeGuards instead.
			'min': min,
			'max': max,
			'_getiter_': _getiter_,
			'_getitem_': _getitem_,
			'_write_': full_write_guard,
			'__builtins__': safe_builtins,
		}
		self._pre_exec_hooks = []
		self._run_counter = 0

	@classmethod
	def from_file(cls, path: Path, *args, **kwargs):
		"""Construct program from the given path to a file."""
		return cls(path.read_text(),
		           *args,
		           file_name=path.name,
		           **kwargs)  # pylint: disable=missing-kwoa

	@property
	def file_name(self) -> str:
		return self._file_name

	@property
	def compilation_warnings(self):
		return self._compilation_warnings

	def set_global(self, name, value):
		self._globals[name] = value

	def add_pre_exec_hook(self, coro):
		self._pre_exec_hooks.append(coro)

	def run(self, *, name=None):
		globals_ = self._globals.copy()  # Shallow copy.
		if name is None:
			name = f'{self.file_name}#{self._run_counter}'
		self._run_counter += 1
		return ProgramExecution(name, self._byte_code, globals_, self._pre_exec_hooks)

	def __str__(self) -> str:
		return self.file_name


class _ProgramNodeTransformer(RestrictingNodeTransformer):
	def visit_AsyncFunctionDef(self, node):
		"""Allow async function definitions."""
		return self.node_contents_visit(node)

	def visit_Await(self, node):
		"""Allow await statements."""
		return self.node_contents_visit(node)

	def visit_AsyncWith(self, node):
		"""Allow async with statements."""
		return self.node_contents_visit(node)

	def visit_AsyncFor(self, node):
		"""Allow async for statements."""
		return self.node_contents_visit(node)

	def visit_JoinedStr(self, node):
		"""Allow f-strings (part 1)."""
		return self.node_contents_visit(node)

	def visit_FormattedValue(self, node):
		"""Allow f-strings (part 2)."""
		return self.node_contents_visit(node)

	def visit_AugAssign(self, node):
		"""Allow augmented assignment of attributies.

		E.g., allow "my_instance.my_attr += 3".
		"""
		if isinstance(node.target, ast.Attribute):
			return self.node_contents_visit(node)
		return super().visit_AugAssign(node)

def _getiter_(ob):
	# Allowed sequences
	if isinstance(ob, range):
		return ob
	raise ProgExecError(f'It is not allowed to iterate over "{type(ob).__name__}" sequences.')


def _getitem_(ob, subscript):
	# Allowed sequences
	if isinstance(ob, (list, dict)):
		return ob[subscript]
	raise ProgExecError(f'It is not allowed to get item from "{type(ob).__name__}" sequences.')