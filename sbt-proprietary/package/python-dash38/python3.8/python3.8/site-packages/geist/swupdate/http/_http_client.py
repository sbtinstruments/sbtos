from __future__ import annotations

import asyncio
import json
import logging
from contextlib import AsyncExitStack
from typing import Optional

import aiohttp
from rx.subject import BehaviorSubject, Subject

from ...asyncio import Rift
from ...http.client import Session
from .._errors import (SwupdateQueryFailed, SwupdateStoppedResponding,
                       SwupdateUnexpectedData, SwupdateUnknownEvent)
from .._info import SwupdateEvent, SwupdateInfo, to_swupdate_event

_LOGGER = logging.getLogger(__name__)



class SwupdateClient:
	"""Continuous swupdate status reports."""

	def __init__(
		self,
		*,
		session: Optional[Session] = None,
		host: Optional[str] = None,
		port: Optional[int] = None,
	) -> None:
		"""Construct swupdate service from the given config."""
		self._stack = AsyncExitStack()
		self._rift = Rift(name="swupdate")
		if session is not None:
			self._we_own_the_session = False
			self._session = session
		elif host is not None and port is not None:
			self._we_own_the_session = True
			self._session = Session(hostname=host, port=port)
		else:
			raise ValueError(
				'Specify either "session" or a "host"-and-"port" combination'
			)
		self._reconnect_interval = 5
		self._errors = Subject()  # of `SwupdateError`
		# This is an observable of all `SwupdateInfo` events. That is, a continuous
		# stream of swupdate status reports.
		self.info = BehaviorSubject(SwupdateInfo())  # of `SwupdateInfo`

	@property
	def errors(self):
		"""Return observable of errors.

		The `info` member only returns actual data. If an error occurs, you won't see it
		through the `info` observable. Instead, use this `errors` observable.
		"""
		return self._errors

	def _on_event(self, event: SwupdateEvent) -> None:
		new_info = self.info.value.with_event(event)
		self.info.on_next(new_info)

	async def _query_swupdate(self):
		url = f"{self._session.url}/ws"
		async with self._session.ws_connect(url) as ws:
			async for msg in ws:
				try:
					raw_event = json.loads(msg.data)
				except json.JSONDecodeError as error:
					# There is a bug in SWUpdate 2020.11 where it sends
					# invalid JSON for the info event. We discard one
					# specific case here. This is a temporary work-around.
					if '"source": "{"0":' in msg.data:
						_LOGGER.warning("Got invalid JSON. Discarding event.")
						_LOGGER.debug("Reason:", exc_info=error)
						continue
					# When the error doesn't fall into any of the specific
					# cases above, we forward it.
					self._errors.on_next(SwupdateUnexpectedData(str(error)))
					continue
				try:
					event = to_swupdate_event(raw_event)
				except ValueError as error:
					self._errors.on_next(SwupdateUnexpectedData(str(error)))
				except SwupdateUnknownEvent as error:
					self._errors.on_next(error)
				else:
					self._on_event(event)

	async def _run_query(self, query) -> None:
		while True:
			try:
				await query()
			# Communication exceptions
			except (aiohttp.ClientError, asyncio.TimeoutError) as error:
				error_text = (
					"Timeout" if isinstance(error, asyncio.TimeoutError) else str(error)
				)
				self._errors.on_next(SwupdateStoppedResponding(error_text))
			# General exceptions
			except Exception as error:  # pylint: disable=broad-except
				self._errors.on_next(SwupdateQueryFailed(str(error)))
				_LOGGER.debug("Query exception reason:", exc_info=error)
			# Wait before reconnecting.
			await asyncio.sleep(self._reconnect_interval)

	async def __aenter__(self) -> SwupdateClient:
		"""Open session to swupdate service."""
		await self._stack.__aenter__()
		await self._stack.enter_async_context(self._rift)
		if self._we_own_the_session:
			await self._stack.enter_async_context(self._session)
		self._rift.create_task(self._run_query(self._query_swupdate))
		return self

	async def __aexit__(self, exc_type, exc_value, traceback) -> None:
		"""Close session to swupdate service."""
		await self._stack.__aexit__(exc_type, exc_value, traceback)
