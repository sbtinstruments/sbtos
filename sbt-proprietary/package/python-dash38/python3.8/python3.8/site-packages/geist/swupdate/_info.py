from __future__ import annotations

import logging
from dataclasses import dataclass, replace
from enum import Enum, auto
from typing import Mapping, Type, Union

from ._errors import SwupdateUnknownEvent

_LOGGER = logging.getLogger(__name__)


@dataclass(frozen=True)
class SwupdateInfoEvent:
	"""Info event with source information."""

	# TODO: Make a source enum
	_source: str

	@classmethod
	def from_dict(cls, raw: dict) -> SwupdateInfoEvent:
		"""Return instance created from the given dict."""
		# Read source
		try:
			source = raw["source"]
		except KeyError:
			raise ValueError('Missing "source" entry')
		return cls(source)


@dataclass(frozen=True)
class SwupdateMessageEvent:
	"""Message event with miscellaneous information."""

	level: int
	text: str

	@classmethod
	def from_dict(cls, raw: dict) -> SwupdateMessageEvent:
		"""Return instance created from the given dict."""
		# Read level
		try:
			level = raw["level"]
		except KeyError:
			raise ValueError('Missing "level" entry')
		# Read text
		try:
			text = raw["text"]
		except KeyError:
			raise ValueError('Missing "text" entry')
		return cls(level, text)



@dataclass(frozen=True)
class SwupdateSourceEvent:
	"""Source of the swupdate."""

	source: str

	@classmethod
	def from_dict(cls, raw: dict) -> SwupdateSourceEvent:
		"""Return instance created from the given dict."""
		# Read source
		try:
			source = raw["source"]
		except KeyError:
			raise ValueError('Missing "source" entry')
		return cls(source)


class SwupdateStatus(Enum):
	"""The phases of a software update."""

	INITIAL = auto()  # Not part of the swupdate API. Only defined by geist.
	START = auto()
	RUN = auto()
	SUCCESS = auto()
	FAILURE = auto()
	DONE = auto()


@dataclass(frozen=True)
class SwupdateStatusEvent:
	"""Status event noting that the update is going into a new phase."""

	status: SwupdateStatus

	@classmethod
	def from_dict(cls, raw: dict) -> SwupdateStatusEvent:
		"""Return instance created from the given dict."""
		# Read raw status string
		try:
			status_str = raw["status"]
		except KeyError:
			raise ValueError('Missing "status" entry')
		# Convert status string to the corresponding enum value
		try:
			status = SwupdateStatus[status_str]
		except KeyError:
			raise ValueError('Unknown status value: "{status_str}"')
		return cls(status)


@dataclass(frozen=True)
class SwupdateStepEvent:
	"""Progress event."""

	overall_percent: float

	@classmethod
	def from_dict(cls, raw: dict) -> SwupdateStepEvent:
		"""Return instance created from the given dict."""
		# Ensure that the required fields are present
		try:
			total_steps = int(raw["number"])
			step = int(raw["step"])
			step_percent = int(raw["percent"])
		except (ValueError, KeyError) as error:
			raise ValueError(f'Missing or invalid entry: "{error}"')
		# Parse the fields
		overall_percent = ((step - 1) * 100 + step_percent) / total_steps
		# Constraint to reasonable bounds in case that the event contains bogus values
		overall_percent = min(100, max(0, overall_percent))
		return cls(overall_percent)


SwupdateEvent = Union[
	SwupdateInfoEvent,
	SwupdateMessageEvent,
	SwupdateSourceEvent,
	SwupdateStatusEvent,
	SwupdateStepEvent,
]

_EVENT_MAP: Mapping[str, Type[SwupdateEvent]] = {
	"info": SwupdateInfoEvent,
	"message": SwupdateMessageEvent,
	"source": SwupdateSourceEvent,
	"status": SwupdateStatusEvent,
	"step": SwupdateStepEvent,
}

def to_swupdate_event(raw_event: dict) -> SwupdateEvent:
	"""Parse the raw swupdate event into a SwupdateEvent instance."""
	# Get event type
	try:
		event_type = raw_event["type"]
	except KeyError:
		raise ValueError('Missing "type" key in event dict.')
	# Find the associated event class
	try:
		event_cls = _EVENT_MAP[event_type]
	except KeyError:
		raise SwupdateUnknownEvent(f'Unknown event type "{event_type}".')
	# Construct an event instance
	return event_cls.from_dict(raw_event)


@dataclass(frozen=True)
class SwupdateInfo:
	"""Status and progress of a software update."""

	status: SwupdateStatus = SwupdateStatus.INITIAL
	overall_percent: float = 0

	def __post__init__(self) -> None:
		if not 0 <= self.overall_percent <= 100:
			raise ValueError(
				"Swupdate overall percent must be between 0 and 100 (both inclusive)"
			)

	def with_event(self, event: SwupdateEvent) -> SwupdateInfo:
		"""Returns a copy with the given update event applied.

		Does not modify this instance. Returns a new Swupdate instance (or
		self if there are no changes).
		"""
		changes: dict
		if isinstance(event, SwupdateStatusEvent):
			changes = {"status": event.status}
			# Reset percent on start
			if event.status == SwupdateStatus.START:
				changes["overall_percent"] = 0
		elif isinstance(event, SwupdateStepEvent):
			changes = {"overall_percent": event.overall_percent}
			# If dash is started mid-measurement, we will miss the initial 'status'
			# message. Since we are receiving 'step' messages, however, we can
			# safely assume that the 'status' is 'RUN'.
			if self.status == SwupdateStatus.INITIAL:
				changes["status"] = SwupdateStatus.RUN
		elif isinstance(event, (SwupdateSourceEvent, SwupdateInfoEvent, SwupdateMessageEvent)):
			# These events have no changes for the progress
			return self
		else:
			raise ValueError(f'Unknown event: "{event}"')
		return replace(self, **changes)
