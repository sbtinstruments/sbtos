import logging
import sqlite3
import dataclasses
from contextlib import contextmanager
from pathlib import Path
from typing import Optional, Tuple

from ._aiosql import get_package_queries
from ._error import DatabaseError

_LOGGER = logging.getLogger(__name__)


class SqliteDatabase:
	"""Sqlite database interface."""

	def __init__(
		self,
		db_path: Path,
		*,
		query_package: Optional[str] = None,
		record_classes: Optional[dict] = None,
		foreign_key_support: bool = True,
		min_sqlite_version: Optional[Tuple[int, int , int]] = None,
	):
		"""Construct using the given config."""
		self._db_path = db_path
		self._foreign_key_support = foreign_key_support
		self._queries = get_package_queries(query_package, "sqlite3", record_classes)
		self._conn = None

		if min_sqlite_version is not None:
			if sqlite3.sqlite_version_info < min_sqlite_version:
				raise RuntimeError(
					f"The sqlite3 version ({sqlite3.sqlite_version}) is too old (we require 3.24.0 or later)"
				)


	@property
	def connection(self):
		"""Return the connection object (or None if disconnected)."""
		return self._conn

	def is_connected(self) -> bool:
		"""Is the database connected."""
		return self._conn is not None

	def raise_if_disconnected(self):
		"""Raise DatabaseError if this is currently disconnected."""
		if not self.is_connected():
			# Early out if not connected
			raise DatabaseError('Invalid operation while disconnected from the database.')

	@contextmanager
	def transaction(self):
		"""Call conn.commit when context ends.

		Raise DatabaseError if the transaction fails. Any driver-specific
		exceptions (e.g., sqlite3.IntegrityError) will be converted into
		the common DatabaseError exception.
		"""
		# Early out if disconnected
		self.raise_if_disconnected()
		# Convert driver-specific exceptions to the common DatabaseError.
		with _wrap_driver_error():
			# Enter transaction manager
			with self._conn as conn:
				yield conn

	def single_query(self, __name: str, *args, **kwargs):
		"""Execute the query with the given name as a single transaction.

		Don't use this function if you need to execute multiple queries
		in a single transaction. Instead, use the transaction context
		manager and manually pass the conn object to the queries.

		Note that the "__name" arugment starts with a dunder to
		avoid conflicts with any "name" attribute in kwargs.
		"""
		with self.transaction():
			return self.query(__name, *args, **kwargs)

	def query(self, __name: str, *args, **kwargs):
		"""Execute the query with the given name.

		This is a low-level function. Call it while inside a transaction
		context.

		If not called inside a transaction context, be aware that driver-
		specific exceptions (e.g., sqlite3.IntegrityError) may be raised.
		"""
		# Early out if disconnected
		self.raise_if_disconnected()
		# Expand dataclass arguments
		if len(args) == 1 and not kwargs and dataclasses.is_dataclass(args[0]):
			kwargs = dataclasses.asdict(args[0])
		# Execute the query
		query = self._find_query(__name)
		return query(self._conn, *args, **kwargs)

	def _find_query(self, name: str):
		query = self._queries
		for part in name.split("."):
			try:
				query = getattr(query, part)
			except AttributeError:
				raise RuntimeError(f'No SQL query with name "{name}"')
		return query

	def connect(self) -> None:
		"""Connect to the database."""
		if self.is_connected():
			# Already connected, early out.
			return
		# Convert driver-specific exceptions to the common DatabaseError.
		with _wrap_driver_error():
			self._conn = sqlite3.connect(self._db_path)
			if self._foreign_key_support:
				self.enable_foreign_key_support()

	def disconnect(self) -> None:
		"""Disconnect from the database."""
		# Early out if already disconnected.
		if not self.is_connected():
			return
		# Convert driver-specific exceptions to the common DatabaseError.
		with _wrap_driver_error():
			self._conn.close()
			self._conn = None

	def enable_foreign_key_support(self) -> None:
		"""Enable foreign key support.

		Raise DatabaseError if not successful.
		"""
		with self.transaction() as conn:
			# Attempt to enable
			conn.execute("PRAGMA foreign_keys = ON")
			# Verify that the attempt succeeded
			cur = conn.execute("PRAGMA foreign_keys")
		# Raise an error if the attempt failed
		fk_enabled = cur.fetchone()[0] == 1
		if not fk_enabled:
			raise DatabaseError("Could not enable foreign key support")

	def __enter__(self):
		self.connect()
		return self

	def __exit__(self, *args, **kwargs):
		self.disconnect()


@contextmanager
def _wrap_driver_error():
	try:
		yield
	# Convert any driver-specific exceptions into the common
	# DatabaseError exception.
	except sqlite3.Error as error:
		raise DatabaseError(str(error))
