import rx
import typing
from rx import operators as ops
from rx.disposable import Disposable


def end_with(args: typing.Iterable):
	def _end_with(source):
		end = rx.from_iterable(args)
		return rx.concat(source, end)
	return _end_with


def sample_until_termination(period, scheduler=None):
	"""Sample the source observable at each interval.

	Unlike rx.operators.sample, sample_until_termination will terminate
	whenever the source observable terminates (and emit a final item at
	that point). That is, sample_until_termination will not needlessly
	prolong the observable for a last 'period' of time before terminating.

	E.g.,

	-------(1)----(2)----(3)----(4)---x
	        |      |      |      |
	[:::::::::::::::sample(4)::::::::::::::::]
	           |             |             |
	----------(1)-----------(3)-----------(4)x

	versus,

	-------(1)----(2)----(3)----(4)---x
	        |      |      |      |
	[::::sample_until_termination(4)::::]
	           |             |        |
	----------(1)-----------(3)------(4)x
	"""
	def _sample_until_termination(source):
		interval = rx.interval(period, scheduler=scheduler)
		# Emit None when the source terminates
		termination = source.pipe(ops.ignore_elements(), end_with([None]))
		# Emit from interval until the source terminates. Then emit None.
		sampler = interval.pipe(ops.take_until(termination), end_with([None]))
		return source.pipe(ops.sample(sampler))
	return _sample_until_termination


def on_termination(func: typing.Callable):
	"""Call the given func on termination.

	Termination is when either:
	  * The observable sequence completes (on_completed)
	  * The observable sequence encounters an error (on_error)
	  * The subscription is disposed
	"""
	def _on_termination(source):
		# Implemented as a 'resource' where only the cleanup logic
		# is relevant.
		resource_factory = lambda: Disposable(func)
		observable_factory = lambda _: source
		return rx.using(resource_factory, observable_factory)
	return _on_termination
