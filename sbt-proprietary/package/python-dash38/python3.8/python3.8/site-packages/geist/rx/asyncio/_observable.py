import asyncio
import functools
import logging
from contextlib import contextmanager
from typing import AsyncIterable, Coroutine
import rx
from rx import operators as ops
from rx import Observable
from rx.core.notification import OnNext, OnError
from rx.core.typing import Observer
from rx.disposable import Disposable
from rx.scheduler.eventloop import AsyncIOScheduler
from ..context import until_context_ends
from .._from_future import from_future


_LOGGER = logging.getLogger(__name__)


def from_coro(coro: Coroutine) -> Observable:
	exceptions = (Exception, asyncio.CancelledError)
	return from_future(asyncio.create_task(coro),
	                   exceptions=exceptions)


def from_aiter(aiter: AsyncIterable):
	"""Reference: https://blog.oakbits.com/rxpy-and-asyncio.html"""
	loop = asyncio.get_event_loop()
	def subscribe(obs: Observer, scheduler=None):
		async def _forward_to_obs():
			try:
				async for value in aiter:
					obs.on_next(value)
				loop.call_soon(obs.on_completed)
			except Exception as error:
				loop.call_soon(functools.partial(obs.on_error, error))
		task = asyncio.create_task(_forward_to_obs())
		return Disposable(lambda: task.cancel())
	return rx.create(subscribe)


async def _to_agen(obs: Observable, *, scheduler=None, name=None, congestion_thres=20):
	"""Reference: https://blog.oakbits.com/rxpy-and-asyncio.html"""
	if scheduler is None:
		queue = asyncio.Queue()
		loop = asyncio.get_event_loop()
		scheduler = AsyncIOScheduler(loop=loop)

	if name is None:
		name = '<no-name>'

	def _log_debug(msg, *args, **kwargs):
		_LOGGER.debug(f'[agen:{name}] {msg}', *args, **kwargs)

	def _test_queue_size():
		qsize = queue.qsize()
		if qsize > congestion_thres:
			_log_debug(f'Queue size is {qsize}. This may be a sign of congestion.')

	def on_next(i):
		queue.put_nowait(i)
		_test_queue_size()

	disposable = obs.pipe(
		ops.materialize(),
	).subscribe(
		on_next=on_next,
		scheduler=scheduler,
	)

	try:
		while True:
			i = await queue.get()
			_test_queue_size()
			if isinstance(i, OnNext):
				yield i.value
				queue.task_done()
			elif isinstance(i, OnError):
				raise(Exception(i.exception)) from i.exception
			else:
				break
	finally:
		disposable.dispose()
		qsize = queue.qsize()
		if qsize > congestion_thres:
			_log_debug(f'Iteration is done. Queue is dropped (size {qsize}).')


@contextmanager
def to_agen(obs: Observable, *args, **kwargs):
	with until_context_ends(obs) as cm_obs:
		yield _to_agen(cm_obs, *args, **kwargs)
