"""Aids the management of tasks."""
import asyncio
import logging
from contextlib import suppress as cl_suppress
from typing import Optional, Union

from rx.subject import Subject

from ...store import DictStore
from .._task import Task

_LOGGER = logging.getLogger(__name__)


class TaskStore(DictStore):
	"""A store of tasks.

	A task is added to the store by calling 'start'. Anologously, a task is removed by calling
	'stop'. This is the only way the user can do so.

	Optional: When (and if) a task finishes, it will automatically remove itself from the store
	after a while. This way, the user has time to retrieve the result (or exception) from the task.
	Simultaneously, old tasks will not linger around forever and fill up the store.

	The above 'restrictions' on the interface ensures that the task store is easy to reason about.
	If needed, said restrictions can easily be lifted to alow for more advanced usage.

	TODO: Rework this class. It's not a proper store if it "deletes" __setitem__
	and __delitem__.
	TaskStore as it is now is closer in functionality to a asyncio.Rift.
	Let's see if one can be implemented in terms of the other.

	TODO: Move the TaskStore.changed observable to a mixin.track_changes
	decorator.
	"""

	def __init__(self,
				 *,
				 auto_remove: bool = False,
				 suppress_on_exit: Union[tuple, Exception, None] = None,
				 log_task_failure: Optional[int] = logging.ERROR):
		"""Construct task store."""
		super().__init__()
		if auto_remove:
			raise NotImplementedError
		self._suppress_on_exit = suppress_on_exit
		self._log_task_failure = log_task_failure
		self.changed = Subject()
		#	self._autoremove_task = AutoremoveTask(self)
		#else:
		#	self._autoremove_task = None

	async def start(self, key, task_or_coro, *args, **kwargs):
		"""Add the given task (with the given key) to the store and start it.

		Raise RuntimeError if the key is already in the store.
		"""
		if key in self:
			raise RuntimeError(f'A task with the key "{key}" is already in the store.')
		# Normalize input
		task = _normalize(task_or_coro, *args, **kwargs)
		# Start the task
		await task.__aenter__()
		# Optionally, log if the task fails
		if self._log_task_failure is not None:
			asyncio.ensure_future(_log_failure(key, task, self._log_task_failure))
		# Add the task to the store
		super().__setitem__(key, task)
		self.changed.on_next(self)
		return task

	async def stop(self, key, suppress=None):
		"""Stop a task by key and remove it from the store.

		Raises any exception raised during the task's execution (if not in the suppres tuple).
		"""
		# Default suppress tuple is the empty tuple
		if suppress is None:
			suppress = ()
		# Raises a KeyError if 'key' is not in the store.
		task = self[key]
		try:
			with cl_suppress(suppress):
				# This call may raise an exception.
				await task.__aexit__(None, None, None)
		# Always remove the program from the store no matter if the __aexit__() raised
		# an exception or not.
		finally:
			super().__delitem__(key)
			self.changed.on_next(self)

	async def stop_all(self, suppress=None):
		"""Stop all tasks and remove them from the store."""
		keys = list(self.keys())
		# Note the race condition between getting the list of keys and
		# attempting to stop each entry. If an entry has been stopped
		# in the meanwhile, calling .stop() in the loop below will raise
		# KeyError. We ignore such KeyErrors as it doesn't matter who
		# stopped the entry first.
		for key in keys:
			try:
				await self.stop(key, suppress=suppress)
			except KeyError:
				pass

	def __setitem__(self, key, value):
		"""Deny direct additions to the store."""
		raise TypeError("'__setitem__' is not supported. Use 'start' instead.")

	def __delitem__(self, key):
		"""Deny direct removals from the store."""
		raise TypeError("'__delitem__' is not supported. Use 'stop' instead.")

	async def __aenter__(self):
		"""Start the auto-remove task (if enabled)."""
		# if self._autoremove_task is not None:
		# 	self._autoremove_task.start()
		return self

	async def __aexit__(self, exc_type, exc_value, traceback):
		"""Stop the auto-remove task (if enabled) and stop all tasks in the store.

		Raises only the first exception encountered while stopping the tasks and
		suppresses the rest.

		Use the suppress_on_exit kwarg to further suppress task exceptions.
		"""
		# if self._autoremove_task is not None:
		# 	loop.run_until_complete(self._autoremove_task.stop())
		try:
			# Attempt to stop all tasks. This may raise an exception if
			# the task failed.
			await self.stop_all(suppress=self._suppress_on_exit)
		finally:
			# No matter what, we stop the remaining tasks while suppressing
			# all exceptions.
			await self.stop_all(suppress=Exception)


def _normalize(task_or_coro, *args, **kwargs) -> Task:
	if asyncio.iscoroutinefunction(task_or_coro):
		return Task(task_or_coro, *args, **kwargs)
	elif isinstance(task_or_coro, Task):
		return task_or_coro
	else:
		raise ValueError(f'Got type "{type(task_or_coro)}". You must provide a Task instance or coroutine function.')

async def _log_failure(key, task, level) -> None:
	await task.wait_until_done()
	error = task.exception
	if error is None:
		return
	_LOGGER.log(level, f'[task:{key}] failed:', exc_info=error)
