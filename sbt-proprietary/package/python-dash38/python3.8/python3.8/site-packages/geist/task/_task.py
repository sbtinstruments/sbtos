"""Anything related to task handling."""
import asyncio
import logging
from contextlib import suppress
from datetime import datetime, timedelta
from typing import Optional

from rx import operators as ops
from rx.subject import BehaviorSubject
from rx import Observable

from ..time import DurationTimer
from ._enum import TaskState
from ._error import TaskError

_LOGGER = logging.getLogger(__name__)


class Task:
	"""A basic class to create well-behaved asynchronous tasks.

	Inspired by the ideas of structured concurrency. Hopefully, Python will adopt
	similar ideas so that this class will become obsolete.

	Basically a wrapper around an asyncio.Task with some useful helpers and defaults.

	The task can be in one of the following states:
		* Idle
		* Running
		* Completed
		* Failed
		* Cancelled

	The initial state is Idle. The state machine is as follows:

	      __aenter__            coro returns              __aexit__
	Idle ------------> Running --------------> Completed -----------> Completed
	  ^                   |
	  |                   |     coro raises               __aexit__
	  | reset             |------------------> Failed --------------> Failed
	  |                   |
	Done                  |     __aexit__
	                      '------------------> Cancelled

	A Task is Done if it is either Completed, Failed or Cancelled.
	Use Task.reset to go from Done to Idle.
	"""

	def __init__(self, coro, *args, **kwargs):
		"""Construct task from the given coroutine function.

		The coroutine is scheduled when __aenter__ is called.
		"""
		self._coro = coro
		self._args = args
		self._kwargs = kwargs
		# The following state can be reset via Task.reset.
		self._state = BehaviorSubject(TaskState.IDLE)
		self._future = None
		self._dt = DurationTimer()

	@property
	def state(self) -> TaskState:
		"""Return this task's current state."""
		return self._state.value

	@property
	def state_changes(self) -> Observable:
		"""Return observable of changes to this task's current state."""
		return self._state.pipe(ops.distinct_until_changed())

	@property
	def idle(self) -> bool:
		"""Is this task idle."""
		return self.state == TaskState.IDLE

	@property
	def running(self) -> bool:
		"""Is this task running."""
		return self.state == TaskState.RUNNING

	@property
	def completed(self) -> bool:
		"""Is this task completed (the coro returned)."""
		return self.state == TaskState.COMPLETED

	@property
	def failed(self) -> bool:
		"""Is this task failed (the coro raised)."""
		return self.state == TaskState.FAILED

	@property
	def cancelled(self) -> bool:
		"""Is this task cancelled."""
		return self.state == TaskState.CANCELLED

	@property
	def done(self) -> bool:
		"""Is this task completed, failed, or cancelled."""
		return TaskState.is_done(self.state)

	@property
	def started_at(self) -> Optional[datetime]:
		"""Return when this task started running (when __aenter__ was called).

		Return None if this task is idle.
		"""
		return self._dt.started_at

	@property
	def done_at(self) -> Optional[datetime]:
		"""Return when this task was done.

		Return None if this task isn't done.
		"""
		return self._dt.done_at

	@property
	def exception(self) -> Optional[Exception]:
		"""Return the exception (if any) that this task has raised.

		Raise TaskError if this task isn't done.

		Return None if this task was cancelled. Use the Task.cancelled
		method to check for cancellation.
		"""
		if not self.done:
			raise TaskError('Task must be done before retriving the exception.')
		try:
			return self._future.exception()
		# As an interesting design choice, asyncio.Future.exception will
		# raise asyncio.CancelledError if the task was cancelled.
		# We simply suppress it here and return None instead. The user code
		# must use Task.cancelled to check for cancellation.
		except asyncio.CancelledError:
			return None

	@property
	def elapsed_duration(self) -> timedelta:
		"""Return duration that the program has been running for."""
		return self._dt.elapsed

	async def wait_until_done(self) -> None:
		"""Wait until this task is done.

		Similar to __await__ but wait_until_done doesn't raise exceptions or
		return the result.
		"""
		await self._state.pipe(ops.filter(TaskState.is_done), ops.first())

	def reset(self) -> None:
		"""Reset a done task so that it can be started again.

		Performs the state transition: done --> idle.

		Do nothing if this task is already idle.

		Raise TaskError if this task is not done.
		"""
		if self.idle:
			return
		if not self.done:
			raise TaskError('Task must be done before resetting.')
		self._future = None
		self._dt.reset()
		self._state.on_next(TaskState.IDLE)

	def _start(self) -> None:
		"""Add the coro to the event loop.

		Raise TaskError if this task isn't idle.
		"""
		if not self.idle:
			raise TaskError('Task must be idle before being started.')
		# An asyncio.Task (or derivative thereof) is returned.
		# Note that asyncio.Task inherits from asyncio.Future.
		self._future = asyncio.create_task(self._coro(*self._args, **self._kwargs))
		self._future.add_done_callback(self._done_callback)
		# Idle -> Running
		self._dt.__enter__()  # Start timer
		self._state.on_next(TaskState.RUNNING)

	async def _stop(self) -> None:
		"""Cancel the underlying asynchronous task.

		Raise any exception (Exception-derivative) that was raised
		during execution.
		"""
		assert not self.idle, 'Task should not be idle when stopped.'
		if self.failed:
			# Task failed. We raise the corresponding exception.
			raise self._future.exception()
		if self.done:
			# Task is done. Nothing more to do.
			return
		# Cancel task and await cancellation
		self._future.cancel()
		try:
			await self._future
		except asyncio.CancelledError:
			pass

	def _done_callback(self, future: asyncio.Future) -> None:
		assert self.running, 'Task should still be in the "running" state when _done_callback is called.'
		self._dt.__exit__(None, None, None)  # Stop timer
		if future.cancelled():  # Never raises
			# Running -> Cancelled
			new_state = TaskState.CANCELLED
		elif future.exception() is not None:  # Raises if cancelled
			# Running -> Failed
			new_state = TaskState.FAILED
		else:
			# Running -> Completed
			new_state = TaskState.COMPLETED
		self._state.on_next(new_state)

	def __await__(self):
		"""Wait for this task to be done.

		Return the result of the task.
		Raise any exception that the task raised (including CancelledError).

		Raise TaskError if this task is idle.
		"""
		if self.idle:
			raise TaskError('Task must not be idle when it is awaited.')
		return self._future.__await__()

	async def __aenter__(self):
		"""Start this task.

		Raise TaskError if this task is already running.
		"""
		self._start()
		return self

	async def __aexit__(self, *args, **kwargs):
		"""Stop this task.

		Raise any exception (Exception-derivative) that was raised
		during execution.
		"""
		await self._stop()
		return self
