import asyncio
import logging
from datetime import datetime
from ..task import Task


_LOGGER = logging.getLogger(__name__)


class AutoremoveTask(Task):
	"""Continously monitors a task store and removes lingering done tasks."""

	def __init__(self, tasks):
		"""Construct auto-remove task."""
		super().__init__(self._cull_tasks_continuously)
		self._tasks = tasks
		self._autoremove_delay = 30  # [s]

	async def remove_done_tasks(self):
		"""Remove all the tasks that have been done for long."""
		now = datetime.now()
		to_be_removed = []
		# Find tasks to remove
		for name, task in self._tasks.items():
			if task.done_at is None:
				continue
			done_time = now - task.done_at
			if done_time.total_seconds() > self._autoremove_delay:
				to_be_removed.append(name)
		# Remove the found tasks (if any)
		for name in to_be_removed:
			try:
				# We are removing the task so errors raised during the execution are irrelevant now
				await self._tasks.stop(name, suppress=Exception)
				_LOGGER.info(f'Auto-removed the task "{name}".')
			except KeyError:
				# The task must have been removed already (or during
				# the 'await task.stop(...)' call).
				continue

	async def _cull_tasks_continuously(self):
		while True:
			await asyncio.sleep(1)
			await self.remove_done_tasks()
