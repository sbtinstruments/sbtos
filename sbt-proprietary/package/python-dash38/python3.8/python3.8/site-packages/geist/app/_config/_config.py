"""Configuration helper functions/classes."""
import argparse
import json
import os
from pathlib import Path
from sys import platform
from jsonschema import Draft4Validator, RefResolver
from ._extend import extend_with_default
from ._dict import expand_jmespath_expr, ExpandJmespathExprError
from .._error import AppError
from .._utility import app_name, app_dir
from ...basic import jmespath_expr_to_dict, merge_left


class ConfigError(AppError):
	"""Raised if configuration failed."""


_GEIST_CONFIG_DIR = Path(__file__).resolve().parent


def _file_handler(uri):
	# Strip the 'file:///' part
	file_path = uri[8:]
	# Try app config directory first
	try:
		with open(os.path.join(app_dir(), 'config', file_path)) as f:
			return json.load(f)
	except FileNotFoundError:
		pass
	# Then try geist config directory
	try:
		with open(os.path.join(_GEIST_CONFIG_DIR, file_path)) as f:
			return json.load(f)
	except FileNotFoundError:
		pass


def config_defaulter(config):
	"""Set configuration default values that must be computed at runtime."""

	config.setdefault('system', {})
	config['system']['dataDirectory'] = ('./data' if platform.startswith('win32')
	                                            else os.path.join('/var', app_name()))


class Config:
	"""Combined interface to the application-wide configuration.

	Gets its values from environment variables, command line arguments, and configuration file.
	"""

	def __init__(self,
	             *,
	             schema_path=None,
	             config_path=None,
	             arg_parser=None,
	             defaulter=None):
		"""Construct config from application defaults.

		It's possible to override the schema path. The default is to look in the application's
		source directory.
		"""
		# argparse.ArgumentParser
		if arg_parser is None:
			self._arg_parser = argparse.ArgumentParser(prog=app_name())
		else:
			self._arg_parser = arg_parser
		self._arg_namespace = argparse.Namespace()
		# Config JSON schema
		self._schema = Config._load_schema(schema_path)
		# Validator
		resolver = RefResolver('file://', self._schema, handlers={'file': _file_handler})
		Draft4Validator.check_schema(self._schema)
		self._validator = Draft4Validator(self._schema, resolver=resolver)

		# Start with the static defaults
		self._data = {}
		extend_with_default(Draft4Validator)(self._schema, resolver=resolver).validate(self._data)
		# Then add some defaults dynamically:
		if defaulter is None:
			defaulter = config_defaulter
			defaulter(self._data)
		# Merge in the config file (overrules the defaults)
		self._config_path, file_data = self._parse_default_file(config_path)
		merge_left(self._data, file_data)
		# Merge in the command line arguments (overrules the config file)
		merge_left(self._data, self._parse_args())
		# Lastly, resolve jmespath expressions.
		# E.g., "{system.dataDirectory}/my_data"
		try:
			# 'Global' variables
			global_ = {
				'global': {
					'appName': app_name(),
				}
			}
			global_['global']['configDirectory'] = str(self._config_path.parent)
			self._data = expand_jmespath_expr(self._data,
			                                  global_,
			                                  expr_filter=r'global\..*')
			# From the config itself
			self._data = expand_jmespath_expr(self._data)
		except ExpandJmespathExprError as error:
			raise ConfigError("Unable to expand jmespath expressions.") from error

	def save(self):
		"""Copy the config from memory to persistent storage."""
		try:
			with self._config_path.open('w') as f:
				json.dump(self._data, f, indent='\t')
		except OSError as error:
			raise ConfigError(f'{error}')

	def to_dict(self):
		"""Return the entire config as a dict."""
		return self._data

	def validate(self, data):
		"""Validate the given data dict."""
		self._validator.validate(data)

	@property
	def arg_namespace(self):
		return self._arg_namespace

	@property
	def _config_dir_env(self):
		env_name = f'{app_name().upper()}_CONFIG_DIRECTORY'
		raw = os.environ.get(env_name)
		return None if raw is None else Path(raw)

	@staticmethod
	def _load_schema(arg_schema_path):
		# Try the provided schema path
		if arg_schema_path:
			try:
				with open(arg_schema_path) as f:
					return json.load(f)
			except FileNotFoundError:
				pass
		# Then, try the app's schema
		try:
			schema_path = os.path.join(app_dir(), 'config', f'{app_name()}.schema.json')
			with open(schema_path) as f:
				return json.load(f)
		except FileNotFoundError:
			pass
		# As a last resort, use our own schema file
		print('INFO: Falling back to schema from geist config dir')
		schema_path = os.path.join(_GEIST_CONFIG_DIR, 'geist.schema.json')
		with open(schema_path) as f:
			return json.load(f)

	def _prioritized_config_paths(self):
		result = []
		# Environment variable (if any)
		if self._config_dir_env:
			result.append(self._config_dir_env / f'{app_name()}.json')
		# Try the primary default (corresponds to when the module is installed normally)
		result.append(Path(f'/etc/{app_name()}/{app_name()}.json'))
		# Try the secondary default (corresponds to when the module is installed as an optional
		# package)
		result.append(Path(f'/opt/etc/{app_name()}/{app_name()}.json'))
		# Try the tertiary default (corresponds to local development builds)
		result.append(Path(f'./{app_name()}.json'))
		return result

	def _parse_default_file(self, arg_config_path):
		# Use the argument path (if any). If this fails, the error will be propagated to the
		# caller
		if arg_config_path is not None:
			config_path = Path(arg_config_path)
			data = self._parse_file(config_path)
			return (config_path, data)

		# Use the first config file that can be found
		for config_path in self._prioritized_config_paths():
			try:
				data = self._parse_file(config_path)
				return (config_path, data)
			except OSError:
				pass

		# No config file---just use defaults
		return (Path(f'./{app_name()}.json'), {})

	def _parse_file(self, path):
		try:
			with open(path) as config_file:
				data = json.load(config_file)
			self._validator.validate(data)
			return data
		except json.JSONDecodeError as error:
			raise ConfigError('Could not parse the config file "{}": {}'.format(path, error)) from error

	def _parse_args(self):
		def _parse_bool(string):
			if 'True' == string:
				return True
			elif 'False' == string:
				return False
			else:
				raise argparse.ArgumentTypeError(f'Must be either "True" or "False" (and not "{string}")')

		# The default arguments
		args = {
			'system.debug': {
				'name_or_flags': ('--debug',),
				'nargs': '?',
				'const': True,
				'type': _parse_bool,
				'help': 'Enable debugging routines/messages.',
				'dest': 'debug',
			},
			'system.asyncio.debug': {
				'name_or_flags': ('--asyncio-debug',),
				'nargs': '?',
				'const': True,
				'type': _parse_bool,
				'help': 'Enable asyncio debugging routines/messages.',
				'dest': 'asyncio_debug',
			},
			'system.foreground': {
				'name_or_flags': ('--foreground',),
				'nargs': '?',
				'const': True,
				'type': _parse_bool,
				'help': 'Run in the foreground (and not as a Unix daemon).',
				'dest': 'foreground',
			},
			'system.dataDirectory': {
				'name_or_flags': ('--data-directory',),
				'nargs': '?',
				'help': 'The directory where all data is stored to or retrieved from.',
				'dest': 'data_directory',
			},
		}

		# Add arguments to the parser
		for arg in args.values():
			name_or_flags = arg['name_or_flags']
			rest = {k: v for k, v in arg.items() if 'name_or_flags' != k}
			self._arg_parser.add_argument(*name_or_flags, **rest)

		# Do the parsing
		parsed = vars(self._arg_parser.parse_args(namespace=self._arg_namespace))
		data = {}

		# Organize the parsed results into the config structure
		for jmespath_expr, arg in args.items():
			value = parsed[arg['dest']]
			if value is None:
				continue
			dct = jmespath_expr_to_dict(jmespath_expr, value)
			merge_left(data, dct)

		self._validator.validate(data)
		return data

	def __str__(self):
		"""Return the config data dict as a string."""
		return str(self._data)

	def __getitem__(self, key):
		"""Get config data with the given key."""
		return self._data[key]
