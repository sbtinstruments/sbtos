"""Daemonize an application with a throng of useful defaults with the App context manager."""
import logging
import os
from asyncio import CancelledError
from contextlib import ExitStack, redirect_stdout, suppress
from typing import Callable, Awaitable, ContextManager
from ._config import Config
from ._error import AppError
from ._asyncio import AsyncioLoop, try_install_uvloop
from ._app_proxy import AppProxy


_LOGGER = logging.getLogger(__name__)
_MainFunc = Callable[[AppProxy], Awaitable[None]]


class App:
	"""Useful defaults for applications.

	Features:
	  * Daemonize the process (enabled per default)
	  * Run async code via asyncio (use App.run)
	  * Set up asyncio to use uvloop (if installed)
	  * JSON-based configuration template
	  * Log to syslog (daemon mode)
	  * Enable warnings
	  * Stack trace dump via SIGUSR1
	  * Object allocation dump via SIGUSR2
	"""

	def __init__(self,
				 *,
				 config_schema_path=None,
				 config_defaulter=None,
				 config_arg_parser=None):
		"""Construct app context manager."""
		self._config = Config(schema_path=config_schema_path,
							  defaulter=config_defaulter,
							  arg_parser=config_arg_parser)
		self._stack = ExitStack()
		self._run_task = None

	@property
	def config(self) -> Config:
		return self._config

	@classmethod
	def launch(cls, coro: _MainFunc, *args, **kwargs):
		"""Create app instance and run the given coroutine function.

		Args and kwargs are forwarded to the app's constructor.
		"""
		with cls(*args, **kwargs) as app:
			return app.run(coro)

	def run(self, coro: _MainFunc):
		"""Execute the coroutine function and return the result.

		This function always creates a new event loop and closes it
		at the end. It should be used as a main entry point for asyncio
		programs, and should ideally only be called once.

		App.run is analogous to the asyncio.run function but with signal
		handler support (for daemon mode).

		App.run blocks until either:
		  * The coroutine completes
		  * The coroutine raises an exception
		  * A signal is caught

		If the coroutine raises an exception, said exception is
		forwarded to the caller.
		If a signal is caught, the coroutine is cancelled.
		"""
		# Early out
		if self._run_task is not None and not self._run_task.done():
			raise AppError('App.run is already executing')
		# Proxy the call
		async def _wrapper():
			async with AppProxy(self) as proxy:
				await coro(proxy)
		# Asyncio setup
		asyncio_config = self.config['system']['asyncio']
		loop = AsyncioLoop(config=asyncio_config, terminate=self._terminate)
		with loop:
			# Run until the task completes (or a signal is caught)
			self._run_task = loop.create_task(_wrapper())
			with suppress(CancelledError):
				return loop.run_until_complete(self._run_task)

	def enter_context(self, context_manager):
		"""Add a context manager to the internal stack.

		Use this as a convenience method instead of creating your
		own ExitStack instance.
		"""
		return self._stack.enter_context(context_manager)

	def _terminate(self, *_):
		"""Cancel the execution of App.run (if any)"""
		if self._run_task is not None and not self._run_task.done():
			self._run_task.cancel()

	def _daemonize(self) -> None:
		working_directory = self.config['system']['dataDirectory']
		self._stack.enter_context(_daemon_context(working_directory))

	def _initialize_faulthandler(self):
		from ._faulthandler import stack_trace_dump_signal
		dump_path = os.path.join(self.config['system']['dataDirectory'], 'stack_trace')
		self._stack.enter_context(stack_trace_dump_signal(dump_path))

	def __enter__(self):
		"""Context manager protocol."""
		try:
			self._stack.__enter__()
			# Enable warnings as early as possible. We want to catch
			# those DeprecationWarnings.
			if self.config['system']['debug']:
				_enable_python_warnings()
			# Daemonize before we start to open system handles (e.g.,
			# log files).
			if not self.config['system']['foreground']:
				self._daemonize()
			# Set up log formatting and log handlers
			_initialize_logging(self.config)
			self._stack.enter_context(_redirect_stdout_to_log())
			# Prefer uvloop for asyncio
			try_install_uvloop()
			# Get a stack trace dump on SIGUSR1
			self._initialize_faulthandler()
		except Exception as error:
			_LOGGER.error('Could not start due to error:', exc_info=error)
			raise
		_LOGGER.info('Started.')
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		"""Context manager protocol."""
		self._stack.__exit__(exc_type, exc_value, traceback)
		# Log exit
		if exc_value is not None:
			# We exitted due to a problem
			_LOGGER.error(f'Stopped due to error:', exc_info=exc_value)
		else:
			_LOGGER.info('Stopped.')


def _enable_python_warnings() -> None:
	import warnings
	warnings.simplefilter('default')

def _daemon_context(working_directory: str) -> ContextManager:
	from daemon import DaemonContext
	# Make sure that the working directory exists
	os.makedirs(working_directory, exist_ok=True)
	return DaemonContext(working_directory=working_directory)

def _initialize_logging(config) -> None:
	from ._logging import initialize_logging
	root_logger = logging.getLogger()
	initialize_logging(root_logger, config=config)

def _redirect_stdout_to_log() -> ContextManager:
	from ._logging import StreamToLogger
	stdout_io = StreamToLogger(logging.getLogger('stdout'))
	return redirect_stdout(stdout_io)
