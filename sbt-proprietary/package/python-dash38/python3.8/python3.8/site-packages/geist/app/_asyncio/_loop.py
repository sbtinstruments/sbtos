import asyncio
from contextlib import ExitStack
from typing import ContextManager
from ._signal_handler import SignalHandler


class AsyncioLoop(ContextManager):
	def __init__(self, *, config, terminate=None):
		self._loop = None
		self._config = config
		self._stack = ExitStack()
		# Signal handler
		self._terminate = terminate

	def __getattr__(self, name):
		"""Forward to the underlying loop."""
		return getattr(self._loop, name)

	def __enter__(self):
		"""Create loop, register signal handlers, etc."""
		self._stack.__enter__()
		loop = asyncio.new_event_loop()
		asyncio.set_event_loop(loop)
		loop.set_debug(self._config['debug'])
		# Slow callbacks are only logged if asyncio debug is enabled
		loop.slow_callback_duration = self._config['slowCallbackDuration']
		# Signal handlers
		if self._terminate is not None:
			signal_handler = SignalHandler(loop, terminate=self._terminate)
			self._stack.enter_context(signal_handler)
		# Remember the loop for cleanup in __exit__.
		self._loop = loop
		return self

	def __exit__(self, *args, **kwargs):
		"""Cancel tasks, close loop, etc.

		Inspired by the clean-up logic in asyncio.run.
		See: https://github.com/python/cpython/blob/3.8/Lib/asyncio/runners.py
		"""
		self._stack.__exit__(*args, **kwargs)
		try:
			_cancel_all_tasks(self._loop)
			self._loop.run_until_complete(self._loop.shutdown_asyncgens())
		finally:
			asyncio.set_event_loop(None)
			self._loop.close()


def _cancel_all_tasks(loop):
	"""Cancel all (pending) tasks.

	Inspired by: https://github.com/python/cpython/blob/3.8/Lib/asyncio/runners.py
	"""
	to_cancel = asyncio.all_tasks(loop)
	if not to_cancel:
		return

	for task in to_cancel:
		task.cancel()

	loop.run_until_complete(
		asyncio.gather(*to_cancel, loop=loop, return_exceptions=True))

	for task in to_cancel:
		if task.cancelled():
			continue
		if task.exception() is not None:
			loop.call_exception_handler({
				'message': 'Unhandled exception during App.__exit__() shutdown',
				'exception': task.exception(),
				'task': task,
			})