import logging
from contextlib import AbstractContextManager
from datetime import datetime, timedelta
from typing import Optional


_LOGGER = logging.getLogger(__name__)


class DurationTimer(AbstractContextManager):
	"""Context manager used to time the duration of the encapsulated code.

	The initial state is Idle. The state machine is as follows:

	      __aenter__            __aexit__
	Idle ------------> Running -----------> Done
	  ^                                       |
	  |                                 reset |
	  '---------------------------------------'
	"""

	def __init__(self):
		self._started_at = None
		self._done_at = None

	@property
	def started_at(self) -> Optional[datetime]:
		"""Return when this timer started running (when __aenter__ was called).

		Returns None if this timer is idle.
		"""
		return self._started_at

	@property
	def done_at(self) -> Optional[datetime]:
		"""Return when this timer was done (when __aexit__ was called).

		Returns None if this timer isn't done.
		"""
		return self._done_at

	@property
	def idle(self) -> bool:
		return self._started_at is None

	@property
	def done(self) -> bool:
		return self._done_at is not None

	@property
	def running(self) -> bool:
		return not self.done and not self.idle

	@property
	def elapsed(self) -> timedelta:
		"""Return duration that this counter has been running for."""
		if self.idle:
			# The not-even-running-yet result
			return timedelta()
		if self.running:
			# The ongoing result
			delta = datetime.now() - self._started_at
			return delta
		# The final result
		return self._done_at - self._started_at

	def reset(self) -> None:
		"""Reset this timer so that it can be started again.

		Performs the state transition: done --> idle.

		Do nothing if this timer is already idle.

		Raise RuntimeError if this timer is not done.
		"""
		if self.idle:
			return
		if not self.done:
			raise RuntimeError('Timer must be done before resetting.')
		self._started_at = None
		self._done_at = None

	def __enter__(self):
		cls_name = type(self).__name__
		assert self.idle, f'{cls_name} must be idle before starting.'
		self._started_at = datetime.now()
		return self

	def __exit__(self, *args, **kwargs):
		cls_name = type(self).__name__
		assert not self.idle, f'{cls_name} must not be idle before stopping.'
		self._done_at = datetime.now()

