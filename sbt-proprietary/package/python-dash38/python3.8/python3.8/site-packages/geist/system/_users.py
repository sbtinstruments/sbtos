from __future__ import annotations

import logging
import socket
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta
from ipaddress import IPv4Address, IPv6Address
from ipaddress import ip_address as create_ip_address
from pathlib import Path
from typing import Iterable, Optional, Tuple, Union

from utmp import UTmpRecordType
from utmp import read as read_utmp

_LOGGER = logging.getLogger(__name__)
_UTMP_FILE = Path("/var/run/utmp")
IPAddress = Union[IPv4Address, IPv6Address]


@dataclass(frozen=True)
class UserInfo:
	"""User information such as name, IP, idle time, etc."""

	name: str
	logged_in_at: datetime
	device_name: str
	idle_time: timedelta
	ip_address: Optional[IPAddress] = None
	hostname: Optional[str] = None

	def is_active(self, max_idle: timedelta = timedelta(minutes=5)) -> bool:
		"""Is this user not idle."""
		return self.idle_time < max_idle


@dataclass(frozen=True)
class Users:
	"""User log-in activity."""

	current: Tuple[UserInfo, ...] = tuple()

	def active(self, **kwargs) -> Iterable[UserInfo]:
		"""Return the non-idle subset of the current users."""
		return (u for u in self.current if u.is_active(**kwargs))

	@classmethod
	def at_present(cls) -> Users:
		"""Return user log-in activity as of now."""
		try:
			with _UTMP_FILE.open("rb") as f:
				contents = f.read()
		except OSError as error:
			raise RuntimeError("Could not get data from UTMP file") from error
		entries = read_utmp(contents)
		current_entries = (e for e in entries if e.type is UTmpRecordType.user_process)
		current_users = tuple(_entry_to_user_info(e) for e in current_entries)
		return cls(current_users)


def _entry_to_user_info(entry) -> UserInfo:
	ip_address = _ip_address(entry.addr0)
	hostname = None if ip_address is None else _hostname(ip_address)
	device_name = entry.line
	idle_time = _idle_time(device_name)
	return UserInfo(
		entry.user, entry.time, device_name, idle_time, ip_address, hostname,
	)


def _ip_address(addr0: int) -> Optional[IPAddress]:
	"""Convert raw decimal address into an IP address object."""
	# The `addr0` field that we get from the `utmp` module assumes a 4-byte
	# signed integer in the system's byte order.
	# In contrast, `create_ip_address` from the `ipaddress` module assumes
	# that the given integer represents four 8-bit unsigned integers with
	# the most significant byte first.
	#
	# If `addr0` is, e.g., `-2013026112` and if we assume two's complement
	# representation on an little-endian system, then we get:
	#
	#   Binary
	#       10001000 00000011 10101000 11000000
	#
	#   32-bit, little-endian, signed integer (`attr0`)
	#       -2013026112
	#
	#   32-bit, big-endian, unsigned integer (`create_ip_address` for `int` arguments)
	#       3232236424
	#
	#   8-bit, unsigned integers (`create_ip_address` for `bytes` arguments)
	#       136      3        168      192
	#
	# Note the IP address hidden in the 8-bit groups: "192.168.3.163". Also note
	# how the IP address appears reversed, in the byte sequence since the most
	# significant byte comes first.
	#
	# To bridge the gap in assumptions between `utmp` and `ipaddress`, we first
	# convert `addr0` back into raw bytes.
	addr0_bytes = addr0.to_bytes(4, byteorder=sys.byteorder, signed=True)
	# Now, we hand over the raw bytes to `create_ip_address` and let the latter
	# apply it's own assumptions (it will convert `bytes` to `int` internally).
	try:
		return create_ip_address(addr0_bytes)
	except ValueError:
		pass
	return None


def _hostname(ip_address: IPAddress) -> Optional[str]:
	try:
		return socket.gethostbyaddr(str(ip_address))[0]
	except OSError:
		return None


def _idle_time(device_name: str) -> timedelta:
	device = Path("/dev") / device_name
	device_stat = device.stat()
	last_activity_at = datetime.fromtimestamp(device_stat.st_atime)
	return datetime.now() - last_activity_at
