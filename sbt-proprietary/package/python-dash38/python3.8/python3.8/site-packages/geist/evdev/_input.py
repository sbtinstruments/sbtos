from __future__ import annotations

import logging
from contextlib import AsyncExitStack
from pathlib import Path
from typing import Optional, Union

import rx
from geist.asyncio import Rift
from rx import Observable
from rx import operators as ops
from rx.subject import Subject

from evdev import InputEvent

from ._constants import EventType, KeyCode, SwitchCode
from ._device import InputDevice

_LOGGER = logging.getLogger(__name__)


AnyCode = Union[KeyCode, SwitchCode]


class Input:
	"""Event device (evdev) input handler."""

	def __init__(self, device_path: Union[Path, str]) -> None:
		self._dev = InputDevice(device_path)
		self._stack = AsyncExitStack()
		self._rift = Rift()
		self._subject = Subject()

	def is_open(self) -> bool:
		"""Is the underlying device open (has `__aenter__` been called)."""
		return self._dev.is_open()

	def observable(
		self,
		*,
		type_: Optional[EventType] = None,
		code: Optional[AnyCode] = None,
		start_with_current: bool = False,
	) -> Observable:
		"""Return obervable of input events that match the given filters.

		Optionally, the current value is included as the first value.
		This makes sense for, e.g., switch inputs.
		"""
		# Early out on missing/invalid/conflicting arguments
		if type_ is not None and code is not None:
			raise ValueError(
				"If you specify 'code', don't also "
				"specify 'type_'. The former implies the latter."
			)
		if start_with_current and type_ is None and code is None:
			raise ValueError(
				"If you specify 'start_with_current', you must also specify"
				"either 'type_' or 'code'.")
		# Return all events per default
		events = self._subject
		# Filter on event type
		if type_ is not None:
			events = events.pipe(ops.filter(lambda e: e.type == type_.value))
		# Filter on event code
		if code is not None:
			events = events.pipe(ops.filter(lambda e: e.code == code.value))
		# Start with the current value
		if start_with_current:
			# Only some event types support reading the current value.
			# Early out if there is a mismatch in the given input arguments.
			types_with_current = [EventType.SWITCH]
			if type_ not in types_with_current:
				raise ValueError(
					f"Event type {type_} does not support "
					"'start_with_current'."
				)
			# Note that the current value is retrieved in a callback function.
			# This is so the current value is retrieved at the time of the
			# subscription, and *not* at the time of this call to
			# `Input.observable`.
			current = rx.from_callable(lambda: self.current_value(code)).pipe(
				# Convert the value to an `InputEvent` to stay consistent
				# with the `events` output.
				# The first two zeros are the time stamp (sec and usec)
				ops.map(lambda v: InputEvent(0, 0, type_, code, v))
			)
			return rx.concat(current, events)
		return events

	def current_value(self, code: SwitchCode) -> int:
		"""Return the current value of the input with the given code.

		Currently, only LED, sound, and switch inputs are supported.
		This is a limitation of the underlying libevdev module.
		"""
		return self._dev.current_value(EventType.SWITCH.value, code)

	async def _event_loop(self) -> None:
		while True:
			async for e in self._dev.events():
				self._subject.on_next(e)

	async def __aenter__(self) -> Input:
		try:
			await self._stack.__aenter__()
			# First, open the input device.
			self._stack.enter_context(self._dev)
			# Second, create the event loop task that will read from
			# the input device continuously.
			await self._stack.enter_async_context(self._rift)
			self._rift.create_task(self._event_loop())
			return self
		except:
			await self._stack.aclose()
			raise

	async def __aexit__(self, exc_type, exc_val, traceback) -> None:
		# Cancel the event loop task when we exit.
		self._rift.cancel()
		await self._stack.__aexit__(exc_type, exc_val, traceback)
